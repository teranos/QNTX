package css

import (
	"fmt"
	"go/ast"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/teranos/QNTX/typegen"
)

// Generator implements typegen.Generator for CSS
type Generator struct{}

// NewGenerator creates a new CSS generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Language returns "css"
func (g *Generator) Language() string {
	return "css"
}

// FileExtension returns "css"
func (g *Generator) FileExtension() string {
	return "css"
}

// GenerateInterface converts a Go struct to CSS custom properties (not applicable for CSS)
// CSS generation only handles const values, not struct types
func (g *Generator) GenerateInterface(name string, structType *ast.StructType) string {
	// CSS doesn't generate from structs - only from const values
	return ""
}

// GenerateUnionType converts const values to CSS custom properties (not applicable for union types)
func (g *Generator) GenerateUnionType(name string, values []string) string {
	// Union types aren't represented in CSS
	return ""
}

// GenerateFile creates a complete CSS file from a typegen.Result
// Generates CSS custom properties from Go const declarations
func (g *Generator) GenerateFile(result *typegen.Result) string {
	var sb strings.Builder

	sb.WriteString("/* Code generated by typegen from Go source. DO NOT EDIT. */\n")
	sb.WriteString("/* Regenerate with: make types */\n")
	sb.WriteString(fmt.Sprintf("/* Source package: %s */\n\n", result.PackageName))

	// Generate CSS custom properties from consts
	if len(result.Consts) > 0 {
		sb.WriteString(":root {\n")

		// Sort const names for deterministic output
		constNames := make([]string, 0, len(result.Consts))
		for name := range result.Consts {
			constNames = append(constNames, name)
		}
		sort.Strings(constNames)

		// Convert const names to CSS custom property names
		// Example: I -> --sym-i, PulseOpen -> --sym-pulse-open
		for _, name := range constNames {
			value := result.Consts[name]
			cssVarName := toKebabCase(name)
			sb.WriteString(fmt.Sprintf("  --%s-%s: \"%s\";\n", result.PackageName, cssVarName, value))
		}

		sb.WriteString("}\n")
	}

	return sb.String()
}

// toKebabCase converts PascalCase or camelCase to kebab-case
// Examples:
//   - I -> i
//   - AM -> am
//   - PulseOpen -> pulse-open
//   - PulseClose -> pulse-close
func toKebabCase(s string) string {
	var result strings.Builder

	for i, r := range s {
		// If uppercase and not first character, and previous char was lowercase
		// or next char is lowercase, add hyphen
		if i > 0 && r >= 'A' && r <= 'Z' {
			// Check if we should add a hyphen before this uppercase letter
			prevIsLower := i > 0 && s[i-1] >= 'a' && s[i-1] <= 'z'
			nextIsLower := i < len(s)-1 && s[i+1] >= 'a' && s[i+1] <= 'z'

			if prevIsLower || nextIsLower {
				result.WriteByte('-')
			}
		}

		// Convert to lowercase
		if r >= 'A' && r <= 'Z' {
			result.WriteByte(byte(r - 'A' + 'a'))
		} else {
			result.WriteRune(r)
		}
	}

	return result.String()
}

// GenerateReadme creates a minimal README for the generated CSS directory
func GenerateReadme(outputDir string) error {
	content := `# Generated CSS

Auto-generated CSS custom properties from Go source code.

**Do not edit manually.** Regenerate with:

` + "```bash" + `
make types        # Regenerate all types including CSS
` + "```" + `
`

	readmePath := filepath.Join(outputDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write README: %w", err)
	}
	return nil
}
