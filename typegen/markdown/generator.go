package markdown

import (
	"fmt"
	"go/ast"
	"sort"
	"strings"

	"github.com/teranos/QNTX/typegen"
)

// Generator implements typegen.Generator for Markdown documentation
type Generator struct {
	// Output directory for generated types (relative to markdown location)
	generatedTypesDir string
}

// NewGenerator creates a new Markdown documentation generator
func NewGenerator() *Generator {
	return &Generator{
		generatedTypesDir: "types/generated",
	}
}

// Language returns "markdown"
func (g *Generator) Language() string {
	return "markdown"
}

// FileExtension returns "md"
func (g *Generator) FileExtension() string {
	return "md"
}

// GenerateInterface creates markdown documentation for a Go struct
func (g *Generator) GenerateInterface(name string, structType *ast.StructType) string {
	var sb strings.Builder

	// Header with type name and anchor ID
	sb.WriteString(fmt.Sprintf("## %s {#%s}\n\n", name, toHeadingID(name)))

	// Build Go struct source
	sb.WriteString("```go\n")
	sb.WriteString(fmt.Sprintf("type %s struct {\n", name))
	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		for _, fieldName := range field.Names {
			// Skip unexported fields
			if !fieldName.IsExported() {
				continue
			}

			// Get field type as string
			fieldType := formatFieldType(field.Type)

			// Get struct tag if present
			tagStr := ""
			if field.Tag != nil {
				tagStr = " " + field.Tag.Value
			}

			sb.WriteString(fmt.Sprintf("\t%s %s%s\n", fieldName.Name, fieldType, tagStr))
		}
	}
	sb.WriteString("}\n```\n")

	return sb.String()
}

// GenerateUnionType creates markdown documentation for a union type
func (g *Generator) GenerateUnionType(name string, values []string) string {
	var sb strings.Builder

	// Sort values for deterministic output
	sort.Strings(values)

	sb.WriteString(fmt.Sprintf("## %s {#%s}\n\n", name, toHeadingID(name)))

	// Build Go type alias with const values
	sb.WriteString("```go\n")
	sb.WriteString(fmt.Sprintf("type %s string\n\nconst (\n", name))
	for _, value := range values {
		// Convert value to const name (e.g., "queued" -> "Queued")
		// Handle single-character values safely
		constName := ""
		if len(value) > 0 {
			constName = strings.ToUpper(string(value[0]))
			if len(value) > 1 {
				constName += value[1:]
			}
		}
		sb.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", name, constName, name, value))
	}
	sb.WriteString(")\n```\n")

	return sb.String()
}

// GenerateFile creates a complete markdown documentation file
func (g *Generator) GenerateFile(result *typegen.Result) string {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# %s Types\n\n", result.PackageName))
	sb.WriteString("<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n")
	sb.WriteString("<!-- Regenerate with: make types -->\n")
	sb.WriteString("<!-- TODO: Migrate to proto generation -->\n\n")

	sb.WriteString("This document shows Go type definitions from the codebase.\n\n")

	// Add links to generated type files
	if result.GitHubBaseURL != "" {
		sb.WriteString("**Generated types**:\n")
		sb.WriteString(fmt.Sprintf("- TypeScript: [`%s/typescript/%s.ts`](%s/%s/typescript/%s.ts)\n", g.generatedTypesDir, result.PackageName, result.GitHubBaseURL, g.generatedTypesDir, result.PackageName))
		sb.WriteString(fmt.Sprintf("- Rust: [`%s/rust/%s.rs`](%s/%s/rust/%s.rs)\n", g.generatedTypesDir, result.PackageName, result.GitHubBaseURL, g.generatedTypesDir, result.PackageName))
		sb.WriteString("\n")
	}

	// Generate const documentation (untyped consts)
	if len(result.Consts) > 0 {
		sb.WriteString("## Constants {#constants}\n\n")

		// Add source link to the file
		if result.SourceFile != "" && result.GitHubBaseURL != "" {
			sb.WriteString(fmt.Sprintf("**Source**: [`%s`](%s/%s)\n\n", result.SourceFile, result.GitHubBaseURL, result.SourceFile))
		}

		sb.WriteString("```go\n")

		// Sort const names for deterministic output
		constNames := make([]string, 0, len(result.Consts))
		for name := range result.Consts {
			constNames = append(constNames, name)
		}
		sort.Strings(constNames)

		for _, name := range constNames {
			value := result.Consts[name]
			sb.WriteString(fmt.Sprintf("const %s = \"%s\"\n", name, value))
		}

		sb.WriteString("```\n\n")
	}

	// Sort type names for deterministic output
	names := make([]string, 0, len(result.Types))
	for name := range result.Types {
		names = append(names, name)
	}
	sort.Strings(names)

	// Add each type with source links
	for i, name := range names {
		typeMarkdown := result.Types[name]

		// Inject source link after the heading if we have position info
		if pos, ok := result.TypePositions[name]; ok {
			// Find the heading line (## TypeName)
			lines := strings.Split(typeMarkdown, "\n")
			if len(lines) > 0 && strings.HasPrefix(lines[0], "## ") && result.GitHubBaseURL != "" {
				// Insert source link after heading
				sourceLink := fmt.Sprintf("\n**Source**: [`%s:%d`](%s/%s#L%d)\n",
					pos.File, pos.Line, result.GitHubBaseURL, pos.File, pos.Line)
				lines = append(lines[:1], append([]string{sourceLink}, lines[1:]...)...)
				typeMarkdown = strings.Join(lines, "\n")
			}
		}

		sb.WriteString(typeMarkdown)
		if i < len(names)-1 {
			sb.WriteString("\n")
		}
	}

	// Generate array documentation (slice literals)
	if len(result.Arrays) > 0 {
		sb.WriteString("\n## Collections\n\n")

		// Sort array names for deterministic output
		arrayNames := make([]string, 0, len(result.Arrays))
		for name := range result.Arrays {
			arrayNames = append(arrayNames, name)
		}
		sort.Strings(arrayNames)

		for _, name := range arrayNames {
			elements := result.Arrays[name]
			sb.WriteString(fmt.Sprintf("### %s {#%s}\n\n", name, toHeadingID(name)))
			sb.WriteString("```go\n")
			sb.WriteString(fmt.Sprintf("var %s = []string{\n", name))
			for _, elem := range elements {
				sb.WriteString(fmt.Sprintf("\t%s,\n", elem))
			}
			sb.WriteString("}\n```\n\n")
		}
	}

	// Generate map documentation (map literals)
	if len(result.Maps) > 0 {
		// Sort map names for deterministic output
		mapNames := make([]string, 0, len(result.Maps))
		for name := range result.Maps {
			mapNames = append(mapNames, name)
		}
		sort.Strings(mapNames)

		for _, name := range mapNames {
			mapData := result.Maps[name]
			sb.WriteString(fmt.Sprintf("### %s {#%s}\n\n", name, toHeadingID(name)))
			sb.WriteString("```go\n")
			sb.WriteString(fmt.Sprintf("var %s = map[string]string{\n", name))

			// Sort map keys for deterministic output
			keys := make([]string, 0, len(mapData))
			for k := range mapData {
				keys = append(keys, k)
			}
			sort.Strings(keys)

			for _, key := range keys {
				value := mapData[key]
				sb.WriteString(fmt.Sprintf("\t%s: %s,\n", formatGoMapKeyWithConsts(key, result.Consts), formatGoMapValueWithConsts(value, result.Consts)))
			}
			sb.WriteString("}\n```\n\n")
		}
	}

	return sb.String()
}

// formatGoMapKeyWithConsts formats a map key for Go markdown output
func formatGoMapKeyWithConsts(key string, consts map[string]string) string {
	if typegen.IsConstReference(key, consts) {
		return key
	}
	return "\"" + key + "\""
}

// formatGoMapValueWithConsts formats a map value for Go markdown output
func formatGoMapValueWithConsts(value string, consts map[string]string) string {
	if typegen.IsConstReference(value, consts) {
		return value
	}
	return "\"" + value + "\""
}

// formatFieldType converts an AST type expression to a string
func formatFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		// Qualified type like time.Time
		if ident, ok := t.X.(*ast.Ident); ok {
			return ident.Name + "." + t.Sel.Name
		}
		return t.Sel.Name
	case *ast.StarExpr:
		// Pointer type
		return "*" + formatFieldType(t.X)
	case *ast.ArrayType:
		// Slice or array
		return "[]" + formatFieldType(t.Elt)
	case *ast.MapType:
		// Map type
		return fmt.Sprintf("map[%s]%s", formatFieldType(t.Key), formatFieldType(t.Value))
	case *ast.InterfaceType:
		return "interface{}"
	default:
		return "unknown"
	}
}

// toHeadingID converts a type name to a lowercase heading ID for anchor links
func toHeadingID(name string) string {
	return strings.ToLower(name)
}
