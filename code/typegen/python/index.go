package python

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/teranos/QNTX/code/typegen/util"
)

// PackageExport represents a package and its exported types for __init__.py
type PackageExport struct {
	PackageName string
	TypeNames   []string
	ConstNames  []string
	ArrayNames  []string
	MapNames    []string
}

// GenerateInitFile creates an __init__.py file that re-exports all generated modules
func GenerateInitFile(outputDir string, exports []PackageExport) error {
	var sb strings.Builder

	// Header
	sb.WriteString("# Code generated by ats/typegen from Go source. DO NOT EDIT.\n")
	sb.WriteString("# Regenerate with: make types\n\n")
	sb.WriteString(`"""QNTX Type Definitions

This package contains Python type definitions generated from QNTX's Go source code.
All types are Python dataclasses compatible with JSON serialization.

Usage:
    from qntx_types import Job, JobStatus
    from qntx_types.async_ import Progress
    from qntx_types.sym import PULSE, COMMAND_SYMBOLS
"""
`)
	sb.WriteString("\n")

	// Sort packages for deterministic output
	sort.Slice(exports, func(i, j int) bool {
		return exports[i].PackageName < exports[j].PackageName
	})

	// Generate imports from each module
	for _, exp := range exports {
		if len(exp.TypeNames) == 0 && len(exp.ConstNames) == 0 {
			continue
		}

		// Handle Python keyword conflict for 'async'
		modName := exp.PackageName
		if modName == "async" {
			modName = "async_"
		}

		// Collect all exports from this module
		var allExports []string

		// Add const names (convert to SCREAMING_SNAKE_CASE)
		for _, name := range exp.ConstNames {
			pyName := strings.ToUpper(util.ToSnakeCase(name))
			allExports = append(allExports, pyName)
		}

		// Add type names
		allExports = append(allExports, exp.TypeNames...)

		// Add array names
		for _, name := range exp.ArrayNames {
			pyName := strings.ToUpper(util.ToSnakeCase(name))
			allExports = append(allExports, pyName)
		}

		// Add map names
		for _, name := range exp.MapNames {
			pyName := strings.ToUpper(util.ToSnakeCase(name))
			allExports = append(allExports, pyName)
		}

		if len(allExports) == 0 {
			continue
		}

		sort.Strings(allExports)

		sb.WriteString(fmt.Sprintf("from .%s import (\n", modName))
		for _, export := range allExports {
			sb.WriteString(fmt.Sprintf("    %s,\n", export))
		}
		sb.WriteString(")\n")
	}

	sb.WriteString("\n")

	// Generate __all__ list
	sb.WriteString("__all__ = [\n")

	for _, exp := range exports {
		if len(exp.TypeNames) == 0 && len(exp.ConstNames) == 0 {
			continue
		}

		// Collect all exports
		var allExports []string

		for _, name := range exp.ConstNames {
			pyName := strings.ToUpper(util.ToSnakeCase(name))
			allExports = append(allExports, pyName)
		}
		allExports = append(allExports, exp.TypeNames...)

		for _, name := range exp.ArrayNames {
			pyName := strings.ToUpper(util.ToSnakeCase(name))
			allExports = append(allExports, pyName)
		}

		for _, name := range exp.MapNames {
			pyName := strings.ToUpper(util.ToSnakeCase(name))
			allExports = append(allExports, pyName)
		}

		sort.Strings(allExports)

		for _, export := range allExports {
			sb.WriteString(fmt.Sprintf("    \"%s\",\n", export))
		}
	}

	sb.WriteString("]\n")

	// Write the file
	initPath := filepath.Join(outputDir, "__init__.py")
	if err := os.WriteFile(initPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write __init__.py: %w", err)
	}

	fmt.Printf("âœ“ Generated %s\n", initPath)
	return nil
}

// GeneratePyProjectToml creates a pyproject.toml for the qntx-types package
func GeneratePyProjectToml(outputDir string) error {
	content := `[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "qntx-types"
version = "0.1.0"
description = "Generated Python types from QNTX Go source"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"

# NOTE: This file is generated by ats/typegen. Run 'make types' to regenerate.

[project.optional-dependencies]
pydantic = ["pydantic>=2.0"]

[tool.hatch.build.targets.wheel]
packages = ["."]
`

	pyprojectPath := filepath.Join(outputDir, "pyproject.toml")
	if err := os.WriteFile(pyprojectPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write pyproject.toml: %w", err)
	}

	return nil
}

// GenerateReadme creates a README.md file for the Python types package
func GenerateReadme(outputDir string, exports []PackageExport) error {
	var sb strings.Builder

	sb.WriteString("# QNTX Python Types\n\n")
	sb.WriteString("Auto-generated Python type definitions from QNTX's Go source code.\n\n")

	sb.WriteString("## Installation\n\n")
	sb.WriteString("**Using uv (recommended):**\n")
	sb.WriteString("```bash\n")
	sb.WriteString("uv pip install -e types/generated/python\n")
	sb.WriteString("# Or add to your project:\n")
	sb.WriteString("uv add ./types/generated/python\n")
	sb.WriteString("```\n\n")
	sb.WriteString("**Using pip:**\n")
	sb.WriteString("```bash\n")
	sb.WriteString("pip install -e types/generated/python\n")
	sb.WriteString("```\n\n")

	sb.WriteString("## Usage\n\n")
	sb.WriteString("```python\n")
	sb.WriteString("from qntx_types import Job, JobStatus, Progress\n")
	sb.WriteString("from qntx_types.sym import PULSE, COMMAND_SYMBOLS\n\n")
	sb.WriteString("# Create a job instance\n")
	sb.WriteString("job = Job(\n")
	sb.WriteString("    id=\"123\",\n")
	sb.WriteString("    handler_name=\"test\",\n")
	sb.WriteString("    status=\"running\",\n")
	sb.WriteString(")\n\n")
	sb.WriteString("# Access symbol constants\n")
	sb.WriteString("print(f\"Pulse symbol: {PULSE}\")\n")
	sb.WriteString("```\n\n")

	sb.WriteString("## Generated Files\n\n")
	sb.WriteString("- [`__init__.py`](./__init__.py) - Package entry point with re-exports\n")

	// Sort exports for deterministic output
	sort.Slice(exports, func(i, j int) bool {
		return exports[i].PackageName < exports[j].PackageName
	})

	// Package descriptions
	descriptions := map[string]string{
		"async":    "Async job types (Job, JobStatus, Progress, etc.)",
		"budget":   "Rate limiting and budget types",
		"schedule": "Pulse scheduling types",
		"server":   "Server API request/response types",
		"sym":      "Symbol constants and mappings",
		"types":    "Core types (Attestation, Event, CodeBlock, etc.)",
	}

	for _, exp := range exports {
		modName := exp.PackageName
		fileName := modName
		if modName == "async" {
			fileName = "async_"
		}
		desc := descriptions[modName]
		if desc == "" {
			desc = fmt.Sprintf("%s types", modName)
		}
		sb.WriteString(fmt.Sprintf("- [`%s.py`](./%s.py) - %s\n", fileName, fileName, desc))
	}

	sb.WriteString("\n## Type Compatibility\n\n")
	sb.WriteString("All types are Python `@dataclass` decorated classes compatible with:\n\n")
	sb.WriteString("- JSON serialization via `dataclasses.asdict()`\n")
	sb.WriteString("- Type checking with mypy/pyright\n")
	sb.WriteString("- IDE autocomplete and documentation\n\n")

	sb.WriteString("### Example: JSON Serialization\n\n")
	sb.WriteString("```python\n")
	sb.WriteString("import json\n")
	sb.WriteString("from dataclasses import asdict\n")
	sb.WriteString("from qntx_types import Job\n\n")
	sb.WriteString("job = Job(id=\"123\", handler_name=\"test\", status=\"completed\")\n")
	sb.WriteString("json_str = json.dumps(asdict(job))\n")
	sb.WriteString("```\n\n")

	sb.WriteString("## Regeneration\n\n")
	sb.WriteString("Types are regenerated with:\n\n")
	sb.WriteString("```bash\n")
	sb.WriteString("make types\n")
	sb.WriteString("# or\n")
	sb.WriteString("./qntx typegen --lang python --output types/generated/\n")
	sb.WriteString("```\n\n")
	sb.WriteString("**Do not manually edit** - changes will be overwritten when types are regenerated.\n")

	readmePath := filepath.Join(outputDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	return nil
}

// FormatFile formats a Python file using black if available
// Returns nil if black is not found (graceful degradation)
func FormatFile(path string) error {
	// For now, Python files don't require formatting
	// Could add black/ruff integration later
	return nil
}
