package commands

import (
	"fmt"
	"os/exec"
	"strings"
	"time"

	"github.com/pterm/pterm"
	"github.com/spf13/cobra"
	"github.com/teranos/QNTX/errors"
	"github.com/teranos/QNTX/qntx-code/vcs/github"
)

// CodeCmd represents the code command
var CodeCmd = &cobra.Command{
	Use:   "code",
	Short: "AI-assisted code review and fix suggestions",
	Long: `AI-assisted code review and fix suggestions from GitHub PRs.

This command integrates with GitHub pull requests to fetch and display
machine-readable fix suggestions generated by Claude Code review.

Examples:
  qntx code pr              # Request AI review for current PR (auto-detect)
  qntx code pr --pr 123     # Request review for specific PR
  qntx code pr --status     # Check status of running review`,
}

// codePrCmd requests Claude Code review for a PR
var codePrCmd = &cobra.Command{
	Use:   "pr",
	Short: "Request AI code review for a pull request",
	Long: `Trigger Claude Code to review a pull request and generate fix suggestions.

This command triggers the Claude Code Review GitHub Actions workflow,
which analyzes the PR and posts machine-parseable fix suggestions.

Examples:
  qntx code pr              # Request review for current PR (auto-detect)
  qntx code pr --pr 123     # Request review for PR #123
  qntx code pr --status     # Check status of running review`,
	RunE: runCodePr,
}

var (
	codePrNumber   int
	codePrStatus   bool
	codePrWorkflow string
)

func init() {
	// PR subcommand flags
	codePrCmd.Flags().IntVar(&codePrNumber, "pr", 0, "Pull request number (auto-detected from current branch if not specified)")
	codePrCmd.Flags().BoolVar(&codePrStatus, "status", false, "Check status of workflow run instead of triggering new run")
	codePrCmd.Flags().StringVar(&codePrWorkflow, "workflow", "claude-code-review.yml", "Workflow file name")

	CodeCmd.AddCommand(codePrCmd)
}

func runCodePr(cmd *cobra.Command, args []string) error {
	// Check status mode
	if codePrStatus {
		return checkCodeWorkflowStatus()
	}

	// Get PR number
	prNumber := codePrNumber
	if prNumber == 0 {
		// Auto-detect from current branch
		detected, err := github.DetectCurrentPR()
		if err != nil {
			return errors.Wrap(err, "failed to auto-detect PR (use --pr to specify manually)")
		}
		prNumber = detected
		pterm.Info.Printf("Auto-detected PR #%d from current branch\n", prNumber)
	}

	pterm.Info.Printf("Triggering Claude Code review for PR #%d...\n", prNumber)

	// Get current branch to use correct workflow version
	branchCmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	branchOutput, err := branchCmd.Output()
	if err != nil {
		return errors.Wrap(err, "failed to get current branch via git rev-parse")
	}
	currentBranch := strings.TrimSpace(string(branchOutput))
	if currentBranch == "" {
		return errors.New("git rev-parse returned empty branch name")
	}

	// Trigger workflow via gh CLI
	workflowCmd := exec.Command("gh", "workflow", "run", codePrWorkflow,
		"--ref", currentBranch,
		"-f", fmt.Sprintf("pr_number=%d", prNumber))

	output, err := workflowCmd.CombinedOutput()
	if err != nil {
		return errors.Wrapf(err, "failed to trigger workflow %s on branch %s (output: %s)", codePrWorkflow, currentBranch, string(output))
	}

	pterm.Success.Printf("Workflow triggered successfully!\n")

	// Wait for workflow to start (mitigate race condition where GetLatestWorkflowRunID
	// might return a different workflow if called too quickly)
	pterm.Info.Println("Waiting for workflow to start...")
	time.Sleep(2 * time.Second)

	// Get the workflow run ID
	runID, err := github.GetLatestWorkflowRunID(codePrWorkflow)
	if err != nil {
		pterm.Warning.Printf("Could not get workflow run ID: %v\n", err)
		pterm.Info.Println("\nTo check the status of the review:")
		pterm.Printf("  qntx code pr --status\n")
		return nil
	}

	pterm.Info.Printf("Run ID: %d\n", runID)
	pterm.Info.Println("‚è≥ Monitoring workflow completion...")

	// Monitor workflow completion
	if err := github.MonitorWorkflowCompletion(runID); err != nil {
		return errors.Wrapf(err, "workflow monitoring failed for run %d", runID)
	}

	pterm.Success.Println("‚úì Workflow completed successfully!")

	// Fetch and display fix suggestions
	return displayPRFixSuggestions(prNumber)
}

// checkCodeWorkflowStatus checks the status of recent workflow runs
func checkCodeWorkflowStatus() error {
	return github.CheckWorkflowStatus(codePrWorkflow)
}

// displayPRFixSuggestions fetches and displays suggestions from PR comments
func displayPRFixSuggestions(prNumber int) error {
	pterm.Info.Println("\nü§ñ Fetching fix suggestions from PR comments...")

	// Fetch suggestions
	suggestions, err := github.FetchFixSuggestions(prNumber)
	if err != nil {
		return errors.Wrapf(err, "failed to fetch suggestions for PR #%d", prNumber)
	}

	if len(suggestions) == 0 {
		pterm.Success.Println("‚úì No issues found - code looks good!")
		return nil
	}

	pterm.Success.Printf("Found %d fix suggestion(s)\n\n", len(suggestions))

	// Display suggestions in a table
	tableData := pterm.TableData{
		{"ID", "Category", "File", "Lines", "Severity", "Issue"},
	}

	for _, s := range suggestions {
		severity := s.Severity
		switch s.Severity {
		case "high":
			severity = pterm.Red(s.Severity)
		case "medium":
			severity = pterm.Yellow(s.Severity)
		case "low":
			severity = pterm.Green(s.Severity)
		}

		tableData = append(tableData, []string{
			s.ID,
			s.Category,
			s.File,
			fmt.Sprintf("%d-%d", s.StartLine, s.EndLine),
			severity,
			truncateString(s.Issue, 60),
		})
	}

	pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()

	pterm.Println()
	pterm.Info.Printf("View full PR: gh pr view %d\n", prNumber)

	return nil
}

// truncateString truncates a string to maxLen with ellipsis
func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}
