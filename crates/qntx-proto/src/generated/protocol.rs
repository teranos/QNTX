// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub qntx_version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub license: ::prost::alloc::string::String,
}
/// Service endpoints the plugin can call back to QNTX core
/// Format: "host:port" for TCP (e.g., "localhost:50051")
///
/// Note: Database access is not provided - database is a hard boundary.
/// Plugins should use attestations via ats_store_endpoint instead.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeRequest {
    /// ats_store_endpoint: gRPC endpoint for ATSStoreService
    /// Provides: Attestation creation, querying, and management
    #[prost(string, tag = "1")]
    pub ats_store_endpoint: ::prost::alloc::string::String,
    /// queue_endpoint: gRPC endpoint for QueueService
    /// Provides: Async job enqueue, status, and management
    #[prost(string, tag = "2")]
    pub queue_endpoint: ::prost::alloc::string::String,
    /// auth_token: Simple token for authenticating with service endpoints
    /// Plugins must include this token in all service RPC calls
    #[prost(string, tag = "3")]
    pub auth_token: ::prost::alloc::string::String,
    /// Plugin-specific configuration values
    /// Simple types (string, int, bool) passed as string representations
    /// Complex types (maps, slices) JSON-encoded as strings
    /// Plugins should parse and validate values appropriate to their schema
    #[prost(map = "string, string", tag = "4")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpRequest {
    #[prost(string, tag = "1")]
    pub method: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub headers: ::prost::alloc::vec::Vec<HttpHeader>,
    #[prost(bytes = "vec", tag = "4")]
    pub body: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpResponse {
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(message, repeated, tag = "2")]
    pub headers: ::prost::alloc::vec::Vec<HttpHeader>,
    #[prost(bytes = "vec", tag = "3")]
    pub body: ::prost::alloc::vec::Vec<u8>,
}
/// HTTPHeader represents an HTTP header with support for multiple values.
/// HTTP headers can have multiple values (e.g., Set-Cookie, Accept).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpHeader {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebSocketMessage {
    #[prost(enumeration = "web_socket_message::Type", tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Optional headers/metadata
    #[prost(map = "string, string", tag = "3")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// For latency measurement (Unix timestamp in nanoseconds)
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
}
/// Nested message and enum types in `WebSocketMessage`.
pub mod web_socket_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Connect = 0,
        Data = 1,
        Close = 2,
        /// Client/Server can send for keepalive
        Ping = 3,
        /// Response to PING
        Pong = 4,
        /// Error notification
        Error = 5,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Connect => "CONNECT",
                Self::Data => "DATA",
                Self::Close => "CLOSE",
                Self::Ping => "PING",
                Self::Pong => "PONG",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECT" => Some(Self::Connect),
                "DATA" => Some(Self::Data),
                "CLOSE" => Some(Self::Close),
                "PING" => Some(Self::Ping),
                "PONG" => Some(Self::Pong),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthResponse {
    #[prost(bool, tag = "1")]
    pub healthy: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigSchemaResponse {
    /// Map of config field name to schema definition
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ConfigFieldSchema,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigFieldSchema {
    /// Field type: "string", "number", "boolean", "array"
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Human-readable description of what this field does
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Default value (as string representation)
    #[prost(string, tag = "3")]
    pub default_value: ::prost::alloc::string::String,
    /// Whether this field is required
    #[prost(bool, tag = "4")]
    pub required: bool,
    /// For number types: minimum value (optional)
    #[prost(string, tag = "5")]
    pub min_value: ::prost::alloc::string::String,
    /// For number types: maximum value (optional)
    #[prost(string, tag = "6")]
    pub max_value: ::prost::alloc::string::String,
    /// For string types: validation pattern (regex, optional)
    #[prost(string, tag = "7")]
    pub pattern: ::prost::alloc::string::String,
    /// For array types: element type (optional)
    #[prost(string, tag = "8")]
    pub element_type: ::prost::alloc::string::String,
}
/// InitializeResponse is returned by Initialize RPC
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeResponse {
    /// Handler names this plugin can execute
    /// Examples: \["python.script", "python.webhook", "ixgest.git"\]
    /// Empty list means plugin provides no async handlers (backward compatible)
    #[prost(string, repeated, tag = "1")]
    pub handler_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// ExecuteJobRequest is sent to plugins to execute an async job
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteJobRequest {
    /// For logging/tracking
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    /// Which handler to invoke
    #[prost(string, tag = "2")]
    pub handler_name: ::prost::alloc::string::String,
    /// Job-specific data (JSON)
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Execution timeout (0 = no timeout)
    #[prost(int64, tag = "4")]
    pub timeout_secs: i64,
}
/// ExecuteJobResponse is returned after job execution
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteJobResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Error message if failed
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    /// Optional result data (JSON)
    #[prost(bytes = "vec", tag = "3")]
    pub result: ::prost::alloc::vec::Vec<u8>,
    /// Progress tracking (optional) - Pulse updates job.Progress
    #[prost(int32, tag = "4")]
    pub progress_current: i32,
    #[prost(int32, tag = "5")]
    pub progress_total: i32,
    /// Cost tracking (optional) - Pulse updates job.CostActual
    #[prost(double, tag = "6")]
    pub cost_actual: f64,
}
/// Attestation represents a complete attestation
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attestation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub subjects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub predicates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Unix timestamp in seconds
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    #[prost(string, tag = "7")]
    pub source: ::prost::alloc::string::String,
    /// map\[string\]interface{} as JSON string
    #[prost(string, tag = "8")]
    pub attributes: ::prost::alloc::string::String,
    /// Unix timestamp in seconds
    #[prost(int64, tag = "9")]
    pub created_at: i64,
}
/// AttestationCommand is used for creating attestations
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationCommand {
    #[prost(string, repeated, tag = "1")]
    pub subjects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub predicates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Unix timestamp in seconds. If not set, server uses current time.
    #[prost(int64, optional, tag = "5")]
    pub timestamp: ::core::option::Option<i64>,
    /// JSON-encoded map\[string\]interface{}
    #[prost(string, tag = "6")]
    pub attributes_json: ::prost::alloc::string::String,
}
/// AttestationFilter for querying attestations
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationFilter {
    #[prost(string, repeated, tag = "1")]
    pub subjects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub predicates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Unix timestamp in seconds (0 = no filter)
    #[prost(int64, tag = "5")]
    pub time_start: i64,
    /// Unix timestamp in seconds (0 = no filter)
    #[prost(int64, tag = "6")]
    pub time_end: i64,
    /// Maximum results. If not set, no limit applied.
    #[prost(int32, optional, tag = "7")]
    pub limit: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAttestationRequest {
    /// Simple token-based auth
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub attestation: ::core::option::Option<Attestation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAttestationResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Empty if success
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationExistsRequest {
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttestationExistsResponse {
    #[prost(bool, tag = "1")]
    pub exists: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAttestationRequest {
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub command: ::core::option::Option<AttestationCommand>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAttestationResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    /// The created attestation with generated ID
    #[prost(message, optional, tag = "3")]
    pub attestation: ::core::option::Option<Attestation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAttestationsRequest {
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<AttestationFilter>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAttestationsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub attestations: ::prost::alloc::vec::Vec<Attestation>,
}
/// Job represents an async operation
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// "data.batch-import", "bio.sequence-align"
    #[prost(string, tag = "2")]
    pub handler_name: ::prost::alloc::string::String,
    /// Handler-specific data (JSON)
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// For deduplication and logging
    #[prost(string, tag = "4")]
    pub source: ::prost::alloc::string::String,
    /// queued, running, paused, completed, failed, cancelled
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub progress: ::core::option::Option<Progress>,
    #[prost(double, tag = "7")]
    pub cost_estimate: f64,
    #[prost(double, tag = "8")]
    pub cost_actual: f64,
    #[prost(message, optional, tag = "9")]
    pub pulse_state: ::core::option::Option<PulseState>,
    #[prost(string, tag = "10")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub parent_job_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "12")]
    pub retry_count: i32,
    /// Unix timestamp in seconds
    #[prost(int64, tag = "13")]
    pub created_at: i64,
    /// Unix timestamp in seconds (0 if not started)
    #[prost(int64, tag = "14")]
    pub started_at: i64,
    /// Unix timestamp in seconds (0 if not completed)
    #[prost(int64, tag = "15")]
    pub completed_at: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Progress {
    #[prost(int32, tag = "1")]
    pub current: i32,
    #[prost(int32, tag = "2")]
    pub total: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PulseState {
    #[prost(int32, tag = "1")]
    pub calls_this_minute: i32,
    #[prost(int32, tag = "2")]
    pub calls_remaining: i32,
    #[prost(double, tag = "3")]
    pub spend_today: f64,
    #[prost(double, tag = "4")]
    pub spend_this_month: f64,
    #[prost(double, tag = "5")]
    pub budget_remaining: f64,
    #[prost(bool, tag = "6")]
    pub is_paused: bool,
    #[prost(string, tag = "7")]
    pub pause_reason: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnqueueRequest {
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub job: ::core::option::Option<Job>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnqueueResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    /// The created job ID
    #[prost(string, tag = "3")]
    pub job_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub job: ::core::option::Option<Job>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateJobRequest {
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub job: ::core::option::Option<Job>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateJobResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    #[prost(string, tag = "1")]
    pub auth_token: ::prost::alloc::string::String,
    /// Optional status filter (empty = all)
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    /// Maximum results. If not set, returns all matching jobs.
    #[prost(int32, optional, tag = "3")]
    pub limit: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub jobs: ::prost::alloc::vec::Vec<Job>,
}
/// DaemonStatusMessage represents daemon status update sent to clients
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DaemonStatusMessage {
    /// Always "daemon_status"
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Is daemon running
    #[prost(bool, tag = "2")]
    pub running: bool,
    /// Number of active jobs
    #[prost(int32, tag = "3")]
    pub active_jobs: i32,
    /// Number of queued jobs
    #[prost(int32, tag = "4")]
    pub queued_jobs: i32,
    /// CPU/processing load (0-100)
    #[prost(double, tag = "5")]
    pub load_percent: f64,
    /// Daily budget spent
    #[prost(double, tag = "6")]
    pub budget_daily: f64,
    /// Weekly budget spent
    #[prost(double, tag = "7")]
    pub budget_weekly: f64,
    /// Monthly budget spent
    #[prost(double, tag = "8")]
    pub budget_monthly: f64,
    /// Daily budget limit (config)
    #[prost(double, tag = "9")]
    pub budget_daily_limit: f64,
    /// Weekly budget limit (config)
    #[prost(double, tag = "10")]
    pub budget_weekly_limit: f64,
    /// Monthly budget limit (config)
    #[prost(double, tag = "11")]
    pub budget_monthly_limit: f64,
    /// "running", "draining", "stopped"
    #[prost(string, tag = "12")]
    pub server_state: ::prost::alloc::string::String,
    /// Unix timestamp
    #[prost(int64, tag = "13")]
    pub timestamp: i64,
}
/// JobUpdateMessage represents async job update sent to clients
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobUpdateMessage {
    /// Always "job_update"
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// TODO: Add Job field once Job type is migrated to proto
    /// Job job = 2;                     // Full job details
    ///
    /// Additional metadata
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// StorageWarningMessage represents bounded storage warning
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageWarningMessage {
    /// Always "storage_warning"
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Actor approaching limit
    #[prost(string, tag = "2")]
    pub actor: ::prost::alloc::string::String,
    /// Context approaching limit
    #[prost(string, tag = "3")]
    pub context: ::prost::alloc::string::String,
    /// Current attestation count
    #[prost(int32, tag = "4")]
    pub current: i32,
    /// Configured limit
    #[prost(int32, tag = "5")]
    pub limit: i32,
    /// Percentage full (0.0-1.0)
    #[prost(double, tag = "6")]
    pub fill_percent: f64,
    /// Human-readable time until hitting limit
    #[prost(string, tag = "7")]
    pub time_until_full: ::prost::alloc::string::String,
    /// Unix timestamp
    #[prost(int64, tag = "8")]
    pub timestamp: i64,
}
