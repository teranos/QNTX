// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.32.1
// source: plugin/grpc/protocol/atsstore.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "protocol";

/** Attestation represents a complete attestation */
export interface Attestation {
  id: string;
  subjects: string[];
  predicates: string[];
  contexts: string[];
  actors: string[];
  /** Unix timestamp in seconds */
  timestamp: number;
  source: string;
  /** JSON-encoded map[string]interface{} */
  attributesJson: string;
  /** Unix timestamp in seconds */
  createdAt: number;
}

/** AttestationCommand is used for creating attestations */
export interface AttestationCommand {
  subjects: string[];
  predicates: string[];
  contexts: string[];
  actors: string[];
  /** Unix timestamp in seconds. If not set, server uses current time. */
  timestamp?:
    | number
    | undefined;
  /** JSON-encoded map[string]interface{} */
  attributesJson: string;
}

/** AttestationFilter for querying attestations */
export interface AttestationFilter {
  subjects: string[];
  predicates: string[];
  contexts: string[];
  actors: string[];
  /** Unix timestamp in seconds (0 = no filter) */
  timeStart: number;
  /** Unix timestamp in seconds (0 = no filter) */
  timeEnd: number;
  /** Maximum results. If not set, no limit applied. */
  limit?: number | undefined;
}

export interface CreateAttestationRequest {
  /** Simple token-based auth */
  authToken: string;
  attestation: Attestation | undefined;
}

export interface CreateAttestationResponse {
  success: boolean;
  /** Empty if success */
  error: string;
}

export interface AttestationExistsRequest {
  authToken: string;
  id: string;
}

export interface AttestationExistsResponse {
  exists: boolean;
}

export interface GenerateAttestationRequest {
  authToken: string;
  command: AttestationCommand | undefined;
}

export interface GenerateAttestationResponse {
  success: boolean;
  error: string;
  /** The created attestation with generated ID */
  attestation: Attestation | undefined;
}

export interface GetAttestationsRequest {
  authToken: string;
  filter: AttestationFilter | undefined;
}

export interface GetAttestationsResponse {
  success: boolean;
  error: string;
  attestations: Attestation[];
}

function createBaseAttestation(): Attestation {
  return {
    id: "",
    subjects: [],
    predicates: [],
    contexts: [],
    actors: [],
    timestamp: 0,
    source: "",
    attributesJson: "",
    createdAt: 0,
  };
}

export const Attestation: MessageFns<Attestation> = {
  encode(message: Attestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.subjects) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.predicates) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.contexts) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.actors) {
      writer.uint32(42).string(v!);
    }
    if (message.timestamp !== 0) {
      writer.uint32(48).int64(message.timestamp);
    }
    if (message.source !== "") {
      writer.uint32(58).string(message.source);
    }
    if (message.attributesJson !== "") {
      writer.uint32(66).string(message.attributesJson);
    }
    if (message.createdAt !== 0) {
      writer.uint32(72).int64(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjects.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predicates.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contexts.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.actors.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attributesJson = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attestation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subjects: globalThis.Array.isArray(object?.subjects) ? object.subjects.map((e: any) => globalThis.String(e)) : [],
      predicates: globalThis.Array.isArray(object?.predicates)
        ? object.predicates.map((e: any) => globalThis.String(e))
        : [],
      contexts: globalThis.Array.isArray(object?.contexts) ? object.contexts.map((e: any) => globalThis.String(e)) : [],
      actors: globalThis.Array.isArray(object?.actors) ? object.actors.map((e: any) => globalThis.String(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      attributesJson: isSet(object.attributesJson)
        ? globalThis.String(object.attributesJson)
        : isSet(object.attributes_json)
        ? globalThis.String(object.attributes_json)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.Number(object.created_at)
        : 0,
    };
  },

  toJSON(message: Attestation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subjects?.length) {
      obj.subjects = message.subjects;
    }
    if (message.predicates?.length) {
      obj.predicates = message.predicates;
    }
    if (message.contexts?.length) {
      obj.contexts = message.contexts;
    }
    if (message.actors?.length) {
      obj.actors = message.actors;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.attributesJson !== "") {
      obj.attributesJson = message.attributesJson;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attestation>, I>>(base?: I): Attestation {
    return Attestation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attestation>, I>>(object: I): Attestation {
    const message = createBaseAttestation();
    message.id = object.id ?? "";
    message.subjects = object.subjects?.map((e) => e) || [];
    message.predicates = object.predicates?.map((e) => e) || [];
    message.contexts = object.contexts?.map((e) => e) || [];
    message.actors = object.actors?.map((e) => e) || [];
    message.timestamp = object.timestamp ?? 0;
    message.source = object.source ?? "";
    message.attributesJson = object.attributesJson ?? "";
    message.createdAt = object.createdAt ?? 0;
    return message;
  },
};

function createBaseAttestationCommand(): AttestationCommand {
  return { subjects: [], predicates: [], contexts: [], actors: [], timestamp: undefined, attributesJson: "" };
}

export const AttestationCommand: MessageFns<AttestationCommand> = {
  encode(message: AttestationCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subjects) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.predicates) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.contexts) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.actors) {
      writer.uint32(34).string(v!);
    }
    if (message.timestamp !== undefined) {
      writer.uint32(40).int64(message.timestamp);
    }
    if (message.attributesJson !== "") {
      writer.uint32(50).string(message.attributesJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestationCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestationCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjects.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.predicates.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contexts.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actors.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.attributesJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestationCommand {
    return {
      subjects: globalThis.Array.isArray(object?.subjects) ? object.subjects.map((e: any) => globalThis.String(e)) : [],
      predicates: globalThis.Array.isArray(object?.predicates)
        ? object.predicates.map((e: any) => globalThis.String(e))
        : [],
      contexts: globalThis.Array.isArray(object?.contexts) ? object.contexts.map((e: any) => globalThis.String(e)) : [],
      actors: globalThis.Array.isArray(object?.actors) ? object.actors.map((e: any) => globalThis.String(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : undefined,
      attributesJson: isSet(object.attributesJson)
        ? globalThis.String(object.attributesJson)
        : isSet(object.attributes_json)
        ? globalThis.String(object.attributes_json)
        : "",
    };
  },

  toJSON(message: AttestationCommand): unknown {
    const obj: any = {};
    if (message.subjects?.length) {
      obj.subjects = message.subjects;
    }
    if (message.predicates?.length) {
      obj.predicates = message.predicates;
    }
    if (message.contexts?.length) {
      obj.contexts = message.contexts;
    }
    if (message.actors?.length) {
      obj.actors = message.actors;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.attributesJson !== "") {
      obj.attributesJson = message.attributesJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttestationCommand>, I>>(base?: I): AttestationCommand {
    return AttestationCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttestationCommand>, I>>(object: I): AttestationCommand {
    const message = createBaseAttestationCommand();
    message.subjects = object.subjects?.map((e) => e) || [];
    message.predicates = object.predicates?.map((e) => e) || [];
    message.contexts = object.contexts?.map((e) => e) || [];
    message.actors = object.actors?.map((e) => e) || [];
    message.timestamp = object.timestamp ?? undefined;
    message.attributesJson = object.attributesJson ?? "";
    return message;
  },
};

function createBaseAttestationFilter(): AttestationFilter {
  return { subjects: [], predicates: [], contexts: [], actors: [], timeStart: 0, timeEnd: 0, limit: undefined };
}

export const AttestationFilter: MessageFns<AttestationFilter> = {
  encode(message: AttestationFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subjects) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.predicates) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.contexts) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.actors) {
      writer.uint32(34).string(v!);
    }
    if (message.timeStart !== 0) {
      writer.uint32(40).int64(message.timeStart);
    }
    if (message.timeEnd !== 0) {
      writer.uint32(48).int64(message.timeEnd);
    }
    if (message.limit !== undefined) {
      writer.uint32(56).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestationFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjects.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.predicates.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contexts.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actors.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timeStart = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timeEnd = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestationFilter {
    return {
      subjects: globalThis.Array.isArray(object?.subjects) ? object.subjects.map((e: any) => globalThis.String(e)) : [],
      predicates: globalThis.Array.isArray(object?.predicates)
        ? object.predicates.map((e: any) => globalThis.String(e))
        : [],
      contexts: globalThis.Array.isArray(object?.contexts) ? object.contexts.map((e: any) => globalThis.String(e)) : [],
      actors: globalThis.Array.isArray(object?.actors) ? object.actors.map((e: any) => globalThis.String(e)) : [],
      timeStart: isSet(object.timeStart)
        ? globalThis.Number(object.timeStart)
        : isSet(object.time_start)
        ? globalThis.Number(object.time_start)
        : 0,
      timeEnd: isSet(object.timeEnd)
        ? globalThis.Number(object.timeEnd)
        : isSet(object.time_end)
        ? globalThis.Number(object.time_end)
        : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: AttestationFilter): unknown {
    const obj: any = {};
    if (message.subjects?.length) {
      obj.subjects = message.subjects;
    }
    if (message.predicates?.length) {
      obj.predicates = message.predicates;
    }
    if (message.contexts?.length) {
      obj.contexts = message.contexts;
    }
    if (message.actors?.length) {
      obj.actors = message.actors;
    }
    if (message.timeStart !== 0) {
      obj.timeStart = Math.round(message.timeStart);
    }
    if (message.timeEnd !== 0) {
      obj.timeEnd = Math.round(message.timeEnd);
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttestationFilter>, I>>(base?: I): AttestationFilter {
    return AttestationFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttestationFilter>, I>>(object: I): AttestationFilter {
    const message = createBaseAttestationFilter();
    message.subjects = object.subjects?.map((e) => e) || [];
    message.predicates = object.predicates?.map((e) => e) || [];
    message.contexts = object.contexts?.map((e) => e) || [];
    message.actors = object.actors?.map((e) => e) || [];
    message.timeStart = object.timeStart ?? 0;
    message.timeEnd = object.timeEnd ?? 0;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseCreateAttestationRequest(): CreateAttestationRequest {
  return { authToken: "", attestation: undefined };
}

export const CreateAttestationRequest: MessageFns<CreateAttestationRequest> = {
  encode(message: CreateAttestationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authToken !== "") {
      writer.uint32(10).string(message.authToken);
    }
    if (message.attestation !== undefined) {
      Attestation.encode(message.attestation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAttestationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAttestationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attestation = Attestation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAttestationRequest {
    return {
      authToken: isSet(object.authToken)
        ? globalThis.String(object.authToken)
        : isSet(object.auth_token)
        ? globalThis.String(object.auth_token)
        : "",
      attestation: isSet(object.attestation) ? Attestation.fromJSON(object.attestation) : undefined,
    };
  },

  toJSON(message: CreateAttestationRequest): unknown {
    const obj: any = {};
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    if (message.attestation !== undefined) {
      obj.attestation = Attestation.toJSON(message.attestation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAttestationRequest>, I>>(base?: I): CreateAttestationRequest {
    return CreateAttestationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAttestationRequest>, I>>(object: I): CreateAttestationRequest {
    const message = createBaseCreateAttestationRequest();
    message.authToken = object.authToken ?? "";
    message.attestation = (object.attestation !== undefined && object.attestation !== null)
      ? Attestation.fromPartial(object.attestation)
      : undefined;
    return message;
  },
};

function createBaseCreateAttestationResponse(): CreateAttestationResponse {
  return { success: false, error: "" };
}

export const CreateAttestationResponse: MessageFns<CreateAttestationResponse> = {
  encode(message: CreateAttestationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAttestationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAttestationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAttestationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CreateAttestationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAttestationResponse>, I>>(base?: I): CreateAttestationResponse {
    return CreateAttestationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAttestationResponse>, I>>(object: I): CreateAttestationResponse {
    const message = createBaseCreateAttestationResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseAttestationExistsRequest(): AttestationExistsRequest {
  return { authToken: "", id: "" };
}

export const AttestationExistsRequest: MessageFns<AttestationExistsRequest> = {
  encode(message: AttestationExistsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authToken !== "") {
      writer.uint32(10).string(message.authToken);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestationExistsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestationExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestationExistsRequest {
    return {
      authToken: isSet(object.authToken)
        ? globalThis.String(object.authToken)
        : isSet(object.auth_token)
        ? globalThis.String(object.auth_token)
        : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: AttestationExistsRequest): unknown {
    const obj: any = {};
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttestationExistsRequest>, I>>(base?: I): AttestationExistsRequest {
    return AttestationExistsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttestationExistsRequest>, I>>(object: I): AttestationExistsRequest {
    const message = createBaseAttestationExistsRequest();
    message.authToken = object.authToken ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseAttestationExistsResponse(): AttestationExistsResponse {
  return { exists: false };
}

export const AttestationExistsResponse: MessageFns<AttestationExistsResponse> = {
  encode(message: AttestationExistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestationExistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestationExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestationExistsResponse {
    return { exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false };
  },

  toJSON(message: AttestationExistsResponse): unknown {
    const obj: any = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttestationExistsResponse>, I>>(base?: I): AttestationExistsResponse {
    return AttestationExistsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttestationExistsResponse>, I>>(object: I): AttestationExistsResponse {
    const message = createBaseAttestationExistsResponse();
    message.exists = object.exists ?? false;
    return message;
  },
};

function createBaseGenerateAttestationRequest(): GenerateAttestationRequest {
  return { authToken: "", command: undefined };
}

export const GenerateAttestationRequest: MessageFns<GenerateAttestationRequest> = {
  encode(message: GenerateAttestationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authToken !== "") {
      writer.uint32(10).string(message.authToken);
    }
    if (message.command !== undefined) {
      AttestationCommand.encode(message.command, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAttestationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAttestationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command = AttestationCommand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAttestationRequest {
    return {
      authToken: isSet(object.authToken)
        ? globalThis.String(object.authToken)
        : isSet(object.auth_token)
        ? globalThis.String(object.auth_token)
        : "",
      command: isSet(object.command) ? AttestationCommand.fromJSON(object.command) : undefined,
    };
  },

  toJSON(message: GenerateAttestationRequest): unknown {
    const obj: any = {};
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    if (message.command !== undefined) {
      obj.command = AttestationCommand.toJSON(message.command);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateAttestationRequest>, I>>(base?: I): GenerateAttestationRequest {
    return GenerateAttestationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateAttestationRequest>, I>>(object: I): GenerateAttestationRequest {
    const message = createBaseGenerateAttestationRequest();
    message.authToken = object.authToken ?? "";
    message.command = (object.command !== undefined && object.command !== null)
      ? AttestationCommand.fromPartial(object.command)
      : undefined;
    return message;
  },
};

function createBaseGenerateAttestationResponse(): GenerateAttestationResponse {
  return { success: false, error: "", attestation: undefined };
}

export const GenerateAttestationResponse: MessageFns<GenerateAttestationResponse> = {
  encode(message: GenerateAttestationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.attestation !== undefined) {
      Attestation.encode(message.attestation, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAttestationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAttestationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attestation = Attestation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAttestationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      attestation: isSet(object.attestation) ? Attestation.fromJSON(object.attestation) : undefined,
    };
  },

  toJSON(message: GenerateAttestationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.attestation !== undefined) {
      obj.attestation = Attestation.toJSON(message.attestation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateAttestationResponse>, I>>(base?: I): GenerateAttestationResponse {
    return GenerateAttestationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateAttestationResponse>, I>>(object: I): GenerateAttestationResponse {
    const message = createBaseGenerateAttestationResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.attestation = (object.attestation !== undefined && object.attestation !== null)
      ? Attestation.fromPartial(object.attestation)
      : undefined;
    return message;
  },
};

function createBaseGetAttestationsRequest(): GetAttestationsRequest {
  return { authToken: "", filter: undefined };
}

export const GetAttestationsRequest: MessageFns<GetAttestationsRequest> = {
  encode(message: GetAttestationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authToken !== "") {
      writer.uint32(10).string(message.authToken);
    }
    if (message.filter !== undefined) {
      AttestationFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttestationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttestationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = AttestationFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttestationsRequest {
    return {
      authToken: isSet(object.authToken)
        ? globalThis.String(object.authToken)
        : isSet(object.auth_token)
        ? globalThis.String(object.auth_token)
        : "",
      filter: isSet(object.filter) ? AttestationFilter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: GetAttestationsRequest): unknown {
    const obj: any = {};
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    if (message.filter !== undefined) {
      obj.filter = AttestationFilter.toJSON(message.filter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAttestationsRequest>, I>>(base?: I): GetAttestationsRequest {
    return GetAttestationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAttestationsRequest>, I>>(object: I): GetAttestationsRequest {
    const message = createBaseGetAttestationsRequest();
    message.authToken = object.authToken ?? "";
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? AttestationFilter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseGetAttestationsResponse(): GetAttestationsResponse {
  return { success: false, error: "", attestations: [] };
}

export const GetAttestationsResponse: MessageFns<GetAttestationsResponse> = {
  encode(message: GetAttestationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    for (const v of message.attestations) {
      Attestation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttestationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttestationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attestations.push(Attestation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttestationsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      attestations: globalThis.Array.isArray(object?.attestations)
        ? object.attestations.map((e: any) => Attestation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAttestationsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.attestations?.length) {
      obj.attestations = message.attestations.map((e) => Attestation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAttestationsResponse>, I>>(base?: I): GetAttestationsResponse {
    return GetAttestationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAttestationsResponse>, I>>(object: I): GetAttestationsResponse {
    const message = createBaseGetAttestationsResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.attestations = object.attestations?.map((e) => Attestation.fromPartial(e)) || [];
    return message;
  },
};

/** ATSStoreService provides attestation storage operations for gRPC plugins */
export interface ATSStoreService {
  /** CreateAttestation creates a new attestation */
  CreateAttestation(request: CreateAttestationRequest): Promise<CreateAttestationResponse>;
  /** AttestationExists checks if an attestation exists by ID */
  AttestationExists(request: AttestationExistsRequest): Promise<AttestationExistsResponse>;
  /** GenerateAndCreateAttestation generates an attestation ID and creates it */
  GenerateAndCreateAttestation(request: GenerateAttestationRequest): Promise<GenerateAttestationResponse>;
  /** GetAttestations queries attestations with filters */
  GetAttestations(request: GetAttestationsRequest): Promise<GetAttestationsResponse>;
}

export const ATSStoreServiceServiceName = "protocol.ATSStoreService";
export class ATSStoreServiceClientImpl implements ATSStoreService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ATSStoreServiceServiceName;
    this.rpc = rpc;
    this.CreateAttestation = this.CreateAttestation.bind(this);
    this.AttestationExists = this.AttestationExists.bind(this);
    this.GenerateAndCreateAttestation = this.GenerateAndCreateAttestation.bind(this);
    this.GetAttestations = this.GetAttestations.bind(this);
  }
  CreateAttestation(request: CreateAttestationRequest): Promise<CreateAttestationResponse> {
    const data = CreateAttestationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAttestation", data);
    return promise.then((data) => CreateAttestationResponse.decode(new BinaryReader(data)));
  }

  AttestationExists(request: AttestationExistsRequest): Promise<AttestationExistsResponse> {
    const data = AttestationExistsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AttestationExists", data);
    return promise.then((data) => AttestationExistsResponse.decode(new BinaryReader(data)));
  }

  GenerateAndCreateAttestation(request: GenerateAttestationRequest): Promise<GenerateAttestationResponse> {
    const data = GenerateAttestationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GenerateAndCreateAttestation", data);
    return promise.then((data) => GenerateAttestationResponse.decode(new BinaryReader(data)));
  }

  GetAttestations(request: GetAttestationsRequest): Promise<GetAttestationsResponse> {
    const data = GetAttestationsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAttestations", data);
    return promise.then((data) => GetAttestationsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
