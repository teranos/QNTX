<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QNTX - ssrf-protection</title>
  <link rel="icon" type="image/jpeg" href="../qntx.jpg">
  <link rel="stylesheet" href="../css/core.css">
  <link rel="stylesheet" href="../css/docs.css">
</head>
<body>
<nav class="doc-nav">
  <a href="../index.html">
    <img src="../qntx.jpg" alt="QNTX" class="site-logo">Documentation Home
  </a>
</nav>
<h1>HTTP Client for User-Controlled URLs</h1>
<h2>Why This Exists</h2>
<p><strong>User-controlled URLs are risky.</strong> If your code fetches <code>http://userInput</code>, an attacker can provide <code>http://localhost:6379</code> (probe internal Redis), <code>http://169.254.169.254/metadata</code> (steal AWS credentials), or <code>http://192.168.1.1/admin</code> (scan your network).</p>
<p><strong>SaferClient blocks private IPs and localhost.</strong> It's defense-in-depth, not a security guarantee.</p>
<h2>Rule</h2>
<p>Use <code>SaferClient</code> for user-controlled URLs. Use regular <code>http.Client</code> for trusted URLs.</p>
<pre><code class="language-go">// ❌ Risky for user input
http.Get(userURL)

// ✅ Use this instead
client := httpclient.NewSaferClient(30 * time.Second)
client.Get(userURL)
</code></pre>
<h2>What It Blocks</h2>
<p><strong>Tested and verified:</strong></p>
<ul>
<li>Private IPv4: 10.x, 192.168.x, 172.16-31.x, 127.x</li>
<li>Cloud metadata IP: 169.254.169.254</li>
<li>Localhost: <code>localhost</code>, <code>*.localhost</code></li>
<li>@ character in URLs (credential injection)</li>
<li>file://, ftp://, gopher:// schemes</li>
<li>Redirects to private IPs</li>
<li><strong>All IPv6 addresses</strong> (disabled until comprehensively tested)</li>
</ul>
<p><strong>Not thoroughly tested:</strong></p>
<ul>
<li>DNS rebinding attacks</li>
</ul>
<p><strong>IPv6 Policy</strong>: All IPv6 addresses are rejected until proper test coverage exists for edge cases like IPv4-mapped addresses (::ffff:127.0.0.1), zone IDs, and other IPv6-specific attack vectors. This is a conservative approach - legitimate IPv6 use cases will fail.</p>
<h2>Usage</h2>
<h3>Basic</h3>
<pre><code class="language-go">import "github.com/teranos/QNTX/internal/httpclient"

client := httpclient.NewSaferClient(30 * time.Second)
resp, err := client.Get(userURL)
if err != nil {
    // Blocked or network error
    return err
}
defer resp.Body.Close()
</code></pre>
<h3>HTTPS-Only</h3>
<pre><code class="language-go">maxRedirects := 5
opts := httpclient.SaferClientOptions{
    AllowedSchemes: []string{"https"},
    MaxRedirects:   &amp;maxRedirects,
}
client := httpclient.NewSaferClientWithOptions(30*time.Second, opts)
</code></pre>
<h3>Tests (Disable Protection)</h3>
<pre><code class="language-go">// ⚠️ Tests only
allowPrivateIP := false
opts := httpclient.SaferClientOptions{
    BlockPrivateIP: &amp;allowPrivateIP,
}
client := httpclient.NewSaferClientWithOptions(30*time.Second, opts)
</code></pre>
<h2>How It Works</h2>
<ol>
<li><strong>Pre-validation</strong>: Checks URL scheme, blocks @ character</li>
<li><strong>DNS resolution</strong>: Resolves hostname to IPs at dial time</li>
<li><strong>IP validation</strong>: Blocks if any resolved IP is private</li>
<li><strong>Redirect validation</strong>: Repeats checks for each redirect</li>
</ol>
<p><strong>Why dial-time validation?</strong> Attackers can use DNS to bypass hostname-only filters. <code>evil.com</code> might resolve to <code>127.0.0.1</code>. We check the actual IPs before connecting.</p>
<p><strong>Limitation</strong>: Sophisticated DNS rebinding (where DNS changes between validation and connection) isn't actively tested. The dial-time check mitigates this but isn't foolproof.</p>
<h2>Testing</h2>
<pre><code class="language-bash">go test -v github.com/teranos/QNTX/internal/httpclient
</code></pre>
<p><strong>What's covered</strong>: RFC1918 ranges, loopback, AWS metadata IP, @ injection, scheme blocking, redirect chains</p>
<p><strong>What's missing</strong>: IPv6 edge cases, DNS rebinding simulation, timing attacks</p>
<h2>When to Use</h2>
<p><strong>Use SaferClient for:</strong></p>
<ul>
<li>Webhook URLs from users</li>
<li>Data ingestion from user-provided sources</li>
<li>Link previews, unfurling</li>
<li>Any HTTP request where URL comes from outside your control</li>
</ul>
<p><strong>Use regular http.Client for:</strong></p>
<ul>
<li>Internal service-to-service calls</li>
<li>Hardcoded URLs in your code</li>
<li>URLs from trusted configuration</li>
</ul>
<p><strong>Don't rely on SaferClient for:</strong></p>
<ul>
<li>Certified security requirements</li>
<li>Production systems with sophisticated attackers</li>
<li>IPv6-heavy environments (without adding tests first)</li>
</ul>
<h2>Improving It</h2>
<p>If you need stronger protection:</p>
<ol>
<li>Add IPv6 test cases (especially IPv4-mapped addresses)</li>
<li>Simulate DNS rebinding attacks</li>
<li>Test against actual SSRF payloads from security research</li>
<li>Consider allowlist (only permit known-safe domains) instead of blocklist</li>
</ol>
<p>The current implementation is better than <code>http.Get(userURL)</code>, but it's not enterprise-grade SSRF protection.</p>
<h2>References</h2>
<ul>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html">OWASP SSRF Cheat Sheet</a></li>
<li>Code: <code>internal/httpclient/safer_client.go</code></li>
<li>Tests: <code>internal/httpclient/safer_client_test.go</code></li>
</ul>
<footer class="site-footer">
  <p class="provenance">Generated by sitegen.nix at commit <a href="https://github.com/teranos/QNTX/commit/0e7ca38dd1dcce5d67e9797b91950b21353f137a-dirty">0e7ca38-dirty</a></p>
</footer>
</body>
</html>
