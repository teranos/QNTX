[{"title":"GLOSSARY","path":"GLOSSARY.html","category":"General","content":"QNTX Glossary & Definitive Terms\n\nCore Concepts\n\nATS (Attestation Type System)\nBoth a type system AND storage system for attestations. It defines:\n- The data model for attestations (type system)\n- Storage and retrieval mechanisms (storage system)\n- The query language for accessing attestations (ax)\n- The foundational primitive: \"subject is predicate of context by actor at time\"\n\nAttestation\nA verifiable claim in the form: Subject] is Predicate] of Context] by Actor] at Time]\n- Not a fact, but a "},{"title":"README_TEMPLATE","path":"README_TEMPLATE.html","category":"General","content":"Package README Template\n\nAll package READMEs should follow this structure (philosophy first, then usage):\n\n---\n\nPackage Name]\n\nOptional: Symbol if applicable, e.g., ꩜ for Pulse]\n\nOne-line description of what this package does]\n\nWhy Package Name]?\n\n2-3 paragraphs explaining the philosophy and problem this solves]\n\nThe problem: What problem exists without this package]\n\nPackage] is the answer: How this package solves it]\n\nPhilosophy\n\nOptional: Additional philosophical points or design principles"},{"title":"README","path":"api/README.html","category":"Api","content":"QNTX Server API Reference\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nComplete API documentation for the QNTX server.\n\nREST API\n\n- Health & Status ./health-status.md) (5 endpoints)\n- Configuration ./configuration.md) (1 endpoints)\n- Pulse Schedules ./pulse-schedules.md) (2 endpoints)\n- Pulse Jobs ./pulse-jobs.md) (2 endpoints)\n- Pulse Executions ./pulse-executions.md) (1 endpoints)\n- Plugins ./plugins.md) (3 endpoints)\n- Prose (Documents) ./prose-docum"},{"title":"Configuration","path":"api/configuration.html","category":"Api","content":"Configuration\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\n| Method | Endpoint | Handler |\n|--------|----------|----------|\n| GET, POST, PATCH | /api/config | HandleConfig |\n\n---\n\nGET | POST | PATCH /api/config\n\nHandleConfig serves configuration endpoint\nSupports GET (retrieve config) and POST/PATCH (update config)\nQuery parameters:\n  - ?introspection=true - Returns detailed config with sources\n\nHandler: HandleConfig\n\n---\n\n← Back to API Index ./README"},{"title":"Grpc Plugin","path":"api/grpc-plugin.html","category":"Api","content":"Plugin gRPC API\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\ngRPC interface for external QNTX domain plugins.\n\nProto file: plugin/grpc/protocol/domain.proto ../../plugin/grpc/protocol/domain.proto)\n\nService Methods\n\n| Method | Request | Response | Streaming |\n|--------|---------|----------|-----------|\n| Metadata | Empty | MetadataResponse | No |\n| Initialize | InitializeRequest | Empty | No |\n| Shutdown | Empty | Empty | No |\n| HandleHTTP | HTTPRequest"},{"title":"Health Status","path":"api/health-status.html","category":"Api","content":"Health & Status\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\n| Method | Endpoint | Handler |\n|--------|----------|----------|\n| GET | /api/debug | HandleDebug |\n| GET | /api/dev | HandleDevMode |\n| GET | /api/timeseries/usage | HandleUsageTimeSeries |\n| GET | /health | HandleHealth |\n| GET | /logs/download | HandleLogDownload |\n\n---\n\nGET /api/debug\n\nHandleDebug handles browser console debugging endpoint\nPOST: Add console log to buffer\nGET: Retrieve all "},{"title":"Plugins","path":"api/plugins.html","category":"Api","content":"Plugins\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\n| Method | Endpoint | Handler |\n|--------|----------|----------|\n| GET | /api/plugins | HandlePlugins |\n| POST | /api/plugins/ | HandlePluginAction |\n| GET, PUT | /api/plugins/{name}/config | HandlePluginConfig |\n\n---\n\nGET /api/plugins\n\nHandlePlugins serves plugin information endpoint\nReturns list of installed plugins with their metadata and health status\n\nHandler: HandlePlugins\n\n---\n\nPOST /api/plugin"},{"title":"Prose Documents","path":"api/prose-documents.html","category":"Api","content":"Prose (Documents)\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\n| Method | Endpoint | Handler |\n|--------|----------|----------|\n| GET | /api/prose | HandleProse |\n| GET, PUT | /api/prose/ | HandleProseContent |\n\n---\n\nGET /api/prose\n\nHandleProse returns the prose content tree structure\n\nHandler: HandleProse\n\n---\n\nGET | PUT /api/prose/\n\nHandleProseContent returns the content of a specific prose file\n\nHandler: HandleProseContent\n\n---\n\n← Back to API Index"},{"title":"Pulse Executions","path":"api/pulse-executions.html","category":"Api","content":"Pulse Executions\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\n| Method | Endpoint | Handler |\n|--------|----------|----------|\n| GET | /api/pulse/executions/ | HandlePulseExecution |\n\n---\n\nGET /api/pulse/executions/\n\nHandlePulseExecution handles requests for individual execution\nGET /api/pulse/executions/{executionid}\nGET /api/pulse/executions/{executionid}/logs\n\nHandler: HandlePulseExecution\n\n---\n\n← Back to API Index ./README.md)\n"},{"title":"Pulse Jobs","path":"api/pulse-jobs.html","category":"Api","content":"Pulse Jobs\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\n| Method | Endpoint | Handler |\n|--------|----------|----------|\n| GET | /api/pulse/jobs | HandlePulseJobs |\n| GET | /api/pulse/jobs/ | HandlePulseJob |\n\n---\n\nGET /api/pulse/jobs\n\nHandlePulseJobs handles requests to /api/pulse/jobs\nGET: List all async jobs (active, completed, failed)\n\nHandler: HandlePulseJobs\n\n---\n\nGET /api/pulse/jobs/\n\nHandlePulseJob handles requests to /api/pulse/jobs/{id}\nGET: G"},{"title":"Pulse Schedules","path":"api/pulse-schedules.html","category":"Api","content":"Pulse Schedules\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\n| Method | Endpoint | Handler |\n|--------|----------|----------|\n| GET, POST | /api/pulse/schedules | HandlePulseSchedules |\n| GET, PATCH, DELETE | /api/pulse/schedules/ | HandlePulseSchedule |\n\n---\n\nGET | POST /api/pulse/schedules\n\nHandlePulseSchedules handles requests to /api/pulse/schedules\nGET: List all schedules\nPOST: Create a new schedule\n\nHandler: HandlePulseSchedules\n\n---\n\nGET | PATCH "},{"title":"Websocket","path":"api/websocket.html","category":"Api","content":"WebSocket Protocol\n\n<!-- Code generated by typegen. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nReal-time communication protocol for the QNTX web interface.\n\nEndpoints\n\n| Path | Purpose |\n|------|--------|\n| /ws | Main WebSocket (graph updates, job status, logs) |\n| /lsp | ATS Language Server Protocol (completions, hover) |\n\nMessage Types\n\nAll messages are JSON objects with a type field indicating the message type.\n\nClient → Server\n\nquery\n\nExecute an ATS query\n\n| Field | Description"},{"title":"ADR 001 Domain Plugin Architecture","path":"architecture/ADR-001-domain-plugin-architecture.html","category":"Architecture","content":"ADR-001: Domain Plugin Architecture\n\nStatus: Accepted\nDate: 2026-01-04\nDeciders: QNTX Core Team\n\nContext\n\nQNTX initially had software development functionality (git ingestion, GitHub integration, gopls language server, code editor) tightly coupled to the core. This created challenges:\n\n1. Scope Creep: Core repository accumulated domain-specific code (code, biotech, finance, etc.)\n2. Coupling: Domain logic mixed with core attestation/graph infrastructure\n3. Maintenance: Changes to one domain risk"},{"title":"ADR 002 Plugin Configuration","path":"architecture/ADR-002-plugin-configuration.html","category":"Architecture","content":"ADR-002: Plugin Configuration Management\n\nStatus: Accepted (Updated 2026-01-04)\nDate: 2026-01-04\nDeciders: QNTX Core Team\n\nContext\n\nDomain plugins need configuration for:\n1. Discovery: Where to find plugin binaries\n2. Selection: Which plugins to load (explicit opt-in)\n3. Plugin-specific settings: API keys, workspace paths, feature flags\n\nRequirements:\n- Works with QNTX's \"minimal core\" philosophy (no plugins by default)\n- Simple, centralized configuration in am.toml\n- Supports plugin discovery f"},{"title":"ADR 003 Plugin Communication","path":"architecture/ADR-003-plugin-communication.html","category":"Architecture","content":"ADR-003: Plugin Communication Patterns\n\nStatus: Accepted\nDate: 2026-01-04\nDeciders: QNTX Core Team\n\nContext\n\nDomain plugins need to share data and coordinate work. How should plugins communicate?\n\nRequirements:\n1. Support both built-in and external (gRPC) plugins\n2. Maintain plugin isolation (no tight coupling)\n3. Enable async workflows (git ingestion triggers code analysis)\n4. Provide consistency guarantees\n\nDecision\n\nPrimary Communication: Database Attestations\n\nPlugins are isolated and commun"},{"title":"Bounded Storage","path":"architecture/bounded-storage.html","category":"Architecture","content":"Bounded Storage Architecture\n\nOverview\n\nQNTX implements a configurable bounded storage strategy to prevent unbounded database growth while maintaining attestation history. The system automatically enforces storage limits and provides observability through telemetry.\n\nStorage Limits (16/64/64 Strategy)\n\nThe default strategy enforces three complementary limits:\n\n- 16 attestations per (actor, context) pair\n- 64 contexts per actor\n- 64 actors per entity (subject)\n\nAll limits are configurable via am."},{"title":"Budget Tracking","path":"architecture/budget-tracking.html","category":"Architecture","content":"Budget Tracking Architecture\n\nOverview\n\nQNTX has a two-component budget tracking system where ai/tracker records individual API calls and feeds data to pulse/budget for centralized budget management and enforcement.\n\nComponent Responsibilities\n\nai/tracker\nPurpose: Records every API call for auditing and cost tracking\n\n- Captures API call metadata (model, tokens, cost)\n- Stores detailed usage history\n- Provides usage analytics and reporting\n- Acts as the data collection layer\n\npulse/budget\nPurpos"},{"title":"Config System","path":"architecture/config-system.html","category":"Architecture","content":"Configuration System Architecture\n\nOverview\n\nQNTX uses a layered configuration system with five sources, merged with clear precedence rules. This design allows system-wide defaults, user preferences, team settings, and environment overrides to coexist cleanly.\n\nConfiguration Sources\n\nConfiguration is loaded from multiple sources in this order (lowest to highest precedence):\n\n\n1. System      /etc/qntx/config.toml               System-wide defaults\n2. User        ~/.qntx/config.toml               "},{"title":"Pulse Async Ix","path":"architecture/pulse-async-ix.html","category":"Architecture","content":"Pulse & Async IX: Budget-Controlled Asynchronous Job Processing\n\nOverview\n\nPulse is QNTX's rate-limiting and budget control system for asynchronous operations. It enables long-running, cost-sensitive operations to run asynchronously while adhering to API rate limits and money budgets.\n\nMotivation\n\nModern AI-powered applications often involve:\n- Multiple API calls per operation (batch processing)\n- Real money costs (~$0.002+ per API call)\n- Time-intensive operations (10-30+ seconds)\n- Batch proce"},{"title":"Pulse Resource Coordination","path":"architecture/pulse-resource-coordination.html","category":"Architecture","content":"Pulse Multi-Process Resource Coordination\n\nStatus: Design Proposal (Issue #50)\nRelated: pulse/budget package, pulse/async worker pool\n\nProblem\n\nRunning QNTX on shared infrastructure (beefy server with GPU) alongside other processes:\n- Training jobs, inference services, data processing\n- Each process has resource quotas (e.g., \"max 30% GPU capacity\")\n- Current limitation: QNTX only tracks internal usage, doesn't coordinate with other processes\n- Need to ensure QNTX respects system-wide load and p"},{"title":"Two Phase Jobs","path":"architecture/two-phase-jobs.html","category":"Architecture","content":"Two-Phase Job Pattern\n\nOverview\n\nPulse supports a two-phase job pattern for complex workflows that need to spawn child tasks and aggregate results.\n\nJob Phases\n\nPhase 1: Ingest\n- Process initial data\n- Create sub-entities\n- Enqueue child tasks\n- Track child job IDs\n\nPhase 2: Aggregate\n- Wait for child tasks to complete\n- Aggregate results\n- Perform final processing\n- Update parent entity\n\nImplementation\n\nJobs track their phase using JobMetadata:\n\ngo\ntype JobMetadata struct {\n    Phase string jso"},{"title":"Codemirror Integration","path":"codemirror-integration.html","category":"General","content":"CodeMirror 6 Integration Reference\n\nContext: Reference guide for CodeMirror 6 concepts relevant to QNTX ATS query editor implementation.\n\nRelated: Issue #13 - Track codemirror-languageserver semantic token support\n\nCore CodeMirror 6 Concepts\n\n1. State + View Architecture\n\nEditorState - Immutable document state:\n- Document content\n- Selection/cursor position\n- Extensions configuration\n- All state is immutable\n\nEditorView - DOM rendering and event handling:\n- Renders the state\n- Handles user inter"},{"title":"Config Panel","path":"development/config-panel.html","category":"Development","content":"Config Panel UI Design Specification\n\n> Architecture Reference: For backend config system architecture, see docs/architecture/config-system.md ../architecture/config-system.md)\n\nPurpose\n\nThis document specifies the UI/UX design for the QNTX configuration panel. It defines the visual layout, interaction model, and future product vision for how users interact with configuration in the web UI.\n\nCurrent Issues\n\n1. Size Constraint: Panel is cramped at max-height: 500px\n2. Layout Problem: Overlays con"},{"title":"Design Philosophy","path":"development/design-philosophy.html","category":"Development","content":"qntx Design Philosophy\n\nCore principles for interface design across qntx CLI and web components.\n\nFoundational Principles\n\nData-First Hierarchy\n\nAll interface decisions prioritize data visibility and accessibility over aesthetic concerns.\n\n- Maximize meaningful information density per screen\n- Present information in scannable, structured formats\n- Visual hierarchy emphasizes content over navigation or decoration\n\nPerformance as Constraint\n\nFast loading and minimal resource usage are non-negotiab"},{"title":"Domain Plugin Api Reference","path":"development/domain-plugin-api-reference.html","category":"Development","content":"Domain Plugin API Reference\n\nComplete reference for the DomainPlugin interface and ServiceRegistry.\n\nTable of Contents\n\n- DomainPlugin Interface #domainplugin-interface)\n- ServiceRegistry Interface #serviceregistry-interface)\n- Plugin Lifecycle #plugin-lifecycle)\n- HTTP Handlers #http-handlers)\n- WebSocket Handlers #websocket-handlers)\n- CLI Commands #cli-commands)\n- Error Handling #error-handling)\n\nDomainPlugin Interface\n\ngo\npackage domains\n\nimport (\n    \"context\"\n    \"net/http\"\n\n    \"github.co"},{"title":"External Plugin Guide","path":"development/external-plugin-guide.html","category":"Development","content":"External Plugin Development Guide\n\nThis guide explains how to develop external QNTX domain plugins that run as separate processes and communicate via gRPC.\n\nTable of Contents\n\n- Overview #overview)\n- Architecture #architecture)\n- Quick Start #quick-start)\n- Plugin Structure #plugin-structure)\n- gRPC Protocol #grpc-protocol)\n- Building and Deploying #building-and-deploying)\n- Testing #testing)\n- Best Practices #best-practices)\n\nOverview\n\nThere is one plugin interface: DomainPlugin. Both built-in "},{"title":"Grace","path":"development/grace.html","category":"Development","content":"Opening (✿) and Closing (❀)\n\nGraceful shutdown and startup system for async job processing.\n\nSymbols:\n- ✿ Opening - Graceful startup with orphaned job recovery\n- ❀ Closing - Graceful shutdown with checkpoint preservation\n\n(Formerly codename: GRACE - Graceful Async Cancellation Engine)\n\nImplementation Summary\n\n❀ Closing (Graceful Shutdown)\n- Context propagation: Application → Worker Pool → Jobs → Handlers\n- Task-level atomicity: Jobs complete current task before checkpointing\n- Si"},{"title":"Migrating To Plugins","path":"development/migrating-to-plugins.html","category":"Development","content":"Migrating Existing Features to Domain Plugins\n\nGuide for extracting existing QNTX features into domain plugins.\n\nTable of Contents\n\n- When to Extract a Plugin #when-to-extract-a-plugin)\n- Migration Strategy #migration-strategy)\n- Code Domain Case Study #code-domain-case-study)\n- Step-by-Step Migration #step-by-step-migration)\n- Testing Migrated Plugins #testing-migrated-plugins)\n- Rollback Strategy #rollback-strategy)\n\nWhen to Extract a Plugin\n\nExtract a feature into a plugin when:\n\n✅ Domain C"},{"title":"Pulse Execution History","path":"development/pulse-execution-history.html","category":"Development","content":"Pulse Execution History\n\n> Related: pulse-async-ix.md ../architecture/pulse-async-ix.md) - Core Pulse architecture\n\nOverview\n\nExecution history tracking for Pulse scheduled jobs, enabling users to view past job runs with logs, timing data, and status information.\n\nFeatures\n\n- Execution Records: Track every scheduled job run with unique execution ID\n- Timing Data: Start/completion timestamps and duration in milliseconds\n- Status Tracking: Running, completed, failed states\n- Log Capture: Store exe"},{"title":"Task Logging","path":"development/task-logging.html","category":"Development","content":"Task Logging Implementation Plan\n\nRelated Documentation\n\n- Pulse Execution History pulse-execution-history.md) - Designed the pulseexecutions table with logs field. This document implements the actual log capture mechanism.\n- Pulse Async Architecture ../architecture/pulse-async-ix.md) - Overall Pulse system design and async job architecture.\n- Frontend Status: See GitHub Issue #30 for current Pulse panel status and remaining work.\n\nOverview\n\nThis document outlines the 9-phase implementation plan"},{"title":"Verbosity","path":"development/verbosity.html","category":"Development","content":"Verbosity Levels\n\nWhy progressive verbosity? Developers want different levels of detail at different times. Simple mental model: more v's = more info. LLMs can use higher verbosity for better context.\n\nProgressive verbosity pattern for QNTX CLI commands using the -v flag.\n\nPattern\n\nbash\nqntx <command>        Level 0 (default) - Results and errors only\nqntx <command> -v     Level 1 - Progress, startup, plugin status\nqntx <command> -vv    Level 2 - Queries, timing, config details\nqntx <command> -v"},{"title":"Distribution Strategy","path":"distribution-strategy.html","category":"General","content":"QNTX Distribution Strategy\n\nCurrent State\n\nWhat We Build\n- ✅ Docker images (amd64, arm64) → GHCR\n- ✅ Go CLI binary (local builds only)\n- ⚠️  Tauri apps (macOS, Windows, Android, iOS) → Only CI checks, no releases\n\nWhat We Distribute\n- Docker images: ghcr.io/teranos/qntx:latest and ghcr.io/teranos/qntx:{version}\n- Nothing else publicly available\n\nDistribution Channels\n\n1. GitHub Releases (Quick Win - High Priority)\n\nWhat: Attach binaries to git tags automatically\n\nPlatforms to distrib"},{"title":"Local Inference","path":"getting-started/local-inference.html","category":"Getting Started","content":"Local Inference Setup\n\nWhy Local Inference?\n\nPrivacy, cost, and control. Cloud LLM APIs are convenient but:\n- Cost: $0.001-0.01+ per API call adds up fast\n- Privacy: Your data goes to third-party servers\n- Latency: Network round-trips add 200-1000ms\n- Availability: Internet required, rate limits apply\n\nLocal inference runs models on your hardware. Zero API cost, complete privacy, works offline.\n\nWhy Ollama?\n\nSimplest path from zero to working LLM. No Python, no virtual environments, no CUDA driv"},{"title":"Go Editor","path":"go-editor.html","category":"General","content":"Go Code Editor\n\nQNTX includes Go code editing capabilities with gopls LSP integration.\n\nFeatures\n\n- Syntax highlighting via CodeMirror 6\n- gopls Language Server Protocol integration\n- Real-time diagnostics\n- Code completion (planned)\n- Hover information (planned)\n- Go to definition (planned)\n\nTest Code Block\n\nHere's a simple Go program to test the go code block integration:\n\ngo\npackage main\n\nimport \"fmt\"\n\n// greet returns a greeting message\nfunc greet(name string) string {\n    return fmt.Sprintf"},{"title":"Installation","path":"installation.html","category":"General","content":"Installing QNTX\n\nQNTX is available through multiple installation methods. Choose the one that best fits your workflow.\n\nNix (Recommended)\n\nQNTX uses Nix for reproducible builds and fast binary distribution via Cachix.\n\nInstall\n\nbash\nInstall QNTX CLI\nnix profile install github:teranos/QNTX\n\nVerify installation\nqntx --version\n\n\nRun Without Installing\n\nbash\nRun directly from GitHub\nnix run github:teranos/QNTX -- --help\n\nUse in a temporary shell\nnix shell github:teranos/QNTX\n\n\nSpecific Version\n\nbash"},{"title":"Nix Development","path":"nix-development.html","category":"General","content":"Nix Development Guide\n\nWhy Nix? Eliminates \"works on my machine\" by pinning every dependency - from Go version to system libraries - in a single file. Build today, rebuild in 5 years, get identical binaries.\n\nWhen to use:\n- Building Docker images for multi-arch (auto-handles arm64/amd64)\n- Verifying reproducible builds before CI\n- Quick environment setup without installing Go/Rust locally\n\nWhen not to use:\n- Rapid iteration (local Go build is faster)\n- Network-dependent operations (Nix sandbox b"},{"title":"Ssrf Protection","path":"security/ssrf-protection.html","category":"Security","content":"HTTP Client for User-Controlled URLs\n\nWhy This Exists\n\nUser-controlled URLs are risky. If your code fetches http://userInput, an attacker can provide http://localhost:6379 (probe internal Redis), http://169.254.169.254/metadata (steal AWS credentials), or http://192.168.1.1/admin (scan your network).\n\nSaferClient blocks private IPs and localhost. It's defense-in-depth, not a security guarantee.\n\nRule\n\nUse SaferClient for user-controlled URLs. Use regular http.Client for trusted URLs.\n\ngo\n// ❌ "},{"title":"Pulse Inline Scheduling Tests","path":"testing/pulse-inline-scheduling-tests.html","category":"Testing","content":"Test Plan: Pulse Inline Scheduling (Variation 1)\n\nComprehensive test cases for inline scheduling controls on ATS code blocks.\n\nTest Environment Setup\n\nPrerequisites\n- QNTX server running (make dev)\n- Database with scheduledpulsejobs table\n- ProseMirror editor with pulse integration\n- Browser with DevTools for debugging\n\nTest Data Setup\n\nsql\n-- Ensure pulse tables exist\nSELECT name FROM sqlitemaster WHERE type='table' AND name='scheduledpulsejobs';\n\n-- Clear existing test jobs\nDELETE FROM schedul"},{"title":"Typegen","path":"typegen.html","category":"General","content":"TypeGen - Type Generator\n\nGenerate TypeScript (and other language) type definitions from Go structs.\n\nQuick Start\n\nbash\nGenerate types to stdout\nqntx typegen\n\nGenerate to files\nqntx typegen --output types/generated/\n\nGenerate specific packages\nqntx typegen --packages pulse/async,server\n\n\nMakefile Integration\n\nbash\nmake types        Generate types\nmake types-check  Verify types are up to date\n\n\nStruct Tags\n\njson Tag\nControls field naming and optionality:\n\ngo\ntype Job struct {\n    ID       string "},{"title":"README","path":"types/README.html","category":"Types","content":"QNTX Type Definitions\n\nAuto-generated documentation showing Go source code alongside TypeScript type definitions.\n\n> Purpose: Provides a single source of truth for type definitions across different contexts (ChatGPT projects, documentation, etc.) to prevent type drift.\n\nPackages\n\nCore Types\n\n- types ./types.md) - Core attestation types (As, AsCommand, AxFilter) (11 types)\n- sym ./sym.md) - QNTX symbol constants and collections (0 types)\n\nPulse System\n\n- async ./async.md) - Asynchronous job proce"},{"title":"Async","path":"types/async.html","category":"Types","content":"async Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/async.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/async.ts)\n- Rust: types/generated/rust/async.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/async.rs)\n- Python: types/generated/python/async.py https://github.com/teranos"},{"title":"Budget","path":"types/budget.html","category":"Types","content":"budget Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/budget.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/budget.ts)\n- Rust: types/generated/rust/budget.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/budget.rs)\n- Python: types/generated/python/budget.py https://github.com/t"},{"title":"Git","path":"types/git.html","category":"Types","content":"git Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/git.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/git.ts)\n- Rust: types/generated/rust/git.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/git.rs)\n- Python: types/generated/python/git.py https://github.com/teranos/QNTX/blob/m"},{"title":"Github","path":"types/github.html","category":"Types","content":"github Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/github.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/github.ts)\n- Rust: types/generated/rust/github.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/github.rs)\n- Python: types/generated/python/github.py https://github.com/t"},{"title":"Graph","path":"types/graph.html","category":"Types","content":"graph Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/graph.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/graph.ts)\n- Rust: types/generated/rust/graph.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/graph.rs)\n- Python: types/generated/python/graph.py https://github.com/teranos"},{"title":"Schedule","path":"types/schedule.html","category":"Types","content":"schedule Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/schedule.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/schedule.ts)\n- Rust: types/generated/rust/schedule.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/schedule.rs)\n- Python: types/generated/python/schedule.py https://"},{"title":"Server","path":"types/server.html","category":"Types","content":"server Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/server.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/server.ts)\n- Rust: types/generated/rust/server.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/server.rs)\n- Python: types/generated/python/server.py https://github.com/t"},{"title":"Sym","path":"types/sym.html","category":"Types","content":"sym Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/sym.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/sym.ts)\n- Rust: types/generated/rust/sym.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/sym.rs)\n- Python: types/generated/python/sym.py https://github.com/teranos/QNTX/blob/m"},{"title":"Types","path":"types/types.html","category":"Types","content":"types Types\n\n<!-- Code generated by typegen from Go source. DO NOT EDIT. -->\n<!-- Regenerate with: make types -->\n\nThis document shows Go type definitions from the codebase.\n\nGenerated types:\n- TypeScript: types/generated/typescript/types.ts https://github.com/teranos/QNTX/blob/main/types/generated/typescript/types.ts)\n- Rust: types/generated/rust/types.rs https://github.com/teranos/QNTX/blob/main/types/generated/rust/types.rs)\n- Python: types/generated/python/types.py https://github.com/teranos"},{"title":"Understanding Qntx","path":"understanding-qntx.html","category":"General","content":"Understanding QNTX: Pattern Recognition Analysis\n\nWritten after migrating 10 issues from ExpGraph and exploring the codebase architecture\n\nWhat This Is\n\nQNTX is an attestation-based continuous intelligence system. Not a knowledge base, not a note-taking app, not a database GUI. It's an attempt to answer: \"How do I build understanding that stays current?\"\n\nThe core primitive is the attestation: structured facts of the form \"X has property Y in context Z\". Everything flows from this:\n\n- ATS (Attes"},{"title":"Tile Based Semantic Ui","path":"vision/tile-based-semantic-ui.html","category":"Vision","content":"Tile-Based Semantic UI - Vision\n\nStatus: Aspirational - Core concepts for future UI evolution\n\nCore Concept\n\nTransform entity visualization from nodes as dots to tiles as always-on surfaces - a paradigm shift toward pane-based semantic computing where data is visible without interaction.\n\nKey Principles\n\n1. Tiles as Surfaces, Not Tooltips\n\nCurrent Pattern: Hover to reveal entity details\nVision: Data always visible on tile surface\n\nTiles are persistent information surfaces displaying contextual d"}]