<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QNTX - ADR-003-plugin-communication</title>
  <link rel="icon" type="image/jpeg" href="../qntx.jpg">
  <link rel="stylesheet" href="../css/core.css">
  <link rel="stylesheet" href="../css/docs.css">
</head>
<body>
<nav class="doc-nav">
  <a href="../index.html">
    <img src="../qntx.jpg" alt="QNTX" class="site-logo">Documentation Home
  </a>
</nav>
<h1>ADR-003: Plugin Communication Patterns</h1>
<p><strong>Status:</strong> Accepted
<strong>Date:</strong> 2026-01-04
<strong>Deciders:</strong> QNTX Core Team</p>
<h2>Context</h2>
<p>Domain plugins need to share data and coordinate work. How should plugins communicate?</p>
<p><strong>Requirements</strong>:</p>
<ol>
<li>Support both built-in and external (gRPC) plugins</li>
<li>Maintain plugin isolation (no tight coupling)</li>
<li>Enable async workflows (git ingestion triggers code analysis)</li>
<li>Provide consistency guarantees</li>
</ol>
<h2>Decision</h2>
<h3>Primary Communication: Database Attestations</h3>
<p><strong>Plugins are isolated and communicate only via shared database:</strong></p>
<pre><code>┌─────────────┐
│ Code Plugin │ ──┐
└─────────────┘   │
                  ├──&gt; ┌──────────────┐ &lt;──┐
┌─────────────┐   │    │  Attestation │    │
│Finance Plugin├───┘    │   Database   │    ├─── ┌──────────────┐
└─────────────┘        └──────────────┘    │    │ Biotech Plugin│
                                            └─── └──────────────┘
</code></pre>
<h3>Communication Patterns</h3>
<h4>1. Event Sourcing via Attestations</h4>
<p>Plugins write attestations to record events:</p>
<pre><code class="language-go">// Code plugin creates attestation when git repo is ingested
attestation := &amp;types.As{
    Actor:   "ixgest-git@user",
    Context: "repository_ingested",
    Entity:  "github.com/teranos/QNTX",
    Payload: json.RawMessage(`{"commit_count": 150, "language": "Go"}`),
}
store.Create(ctx, attestation)
</code></pre>
<p>Other plugins query attestations to discover events:</p>
<pre><code class="language-go">// Finance plugin watches for new repositories
filter := &amp;types.AxFilter{
    Context: ptr("repository_ingested"),
}
repos, err := store.Query(ctx, filter)
</code></pre>
<h4>2. State Sharing via Attestations</h4>
<p>Plugins maintain state in attestations:</p>
<pre><code class="language-go">// Code plugin updates file analysis state
attestation := &amp;types.As{
    Actor:   "code-analyzer@system",
    Context: "file_analyzed",
    Entity:  "domains/code/plugin.go",
    Payload: json.RawMessage(`{
        "complexity": 12,
        "coverage": 85.3,
        "last_modified": "2026-01-04"
    }`),
}
</code></pre>
<h4>3. Async Workflows via Pulse Jobs</h4>
<p>Long-running cross-plugin workflows use Pulse jobs:</p>
<pre><code class="language-go">// Code plugin triggers dependency analysis job
job := &amp;async.Job{
    HandlerName: "analyze_dependencies",
    Payload: json.RawMessage(`{"repo": "github.com/teranos/QNTX"}`),
    Source: "code-plugin",
}
queue.Enqueue(ctx, job)
</code></pre>
<h3>No Direct Plugin Communication</h3>
<p><strong>Prohibited</strong>:</p>
<pre><code class="language-go">// ❌ WRONG: Direct plugin-to-plugin calls
financePlugin := registry.Get("finance")
financePlugin.(*finance.Plugin).AnalyzeRepository(repo)
</code></pre>
<p><strong>Rationale</strong>:</p>
<ul>
<li>Tight coupling between plugins</li>
<li>Breaks process isolation (gRPC plugins in different processes)</li>
<li>Circular dependencies</li>
<li>Difficult to version independently</li>
</ul>
<p><strong>Correct approach</strong>:</p>
<pre><code class="language-go">// ✅ RIGHT: Communication via attestations
store.Create(ctx, &amp;types.As{
    Actor:   "code@plugin",
    Context: "repository_ready",
    Entity:  repoURL,
    Payload: json.RawMessage(`{"trigger": "finance_analysis"}`),
})
</code></pre>
<h3>ServiceRegistry: Plugin ↔ QNTX Communication</h3>
<p>Plugins interact with QNTX via ServiceRegistry:</p>
<pre><code class="language-go">type ServiceRegistry interface {
    Database() *sql.DB              // Direct DB access
    Logger(domain string) *zap.SugaredLogger
    Config(domain string) Config
    ATSStore() *storage.SQLStore    // Attestation CRUD
}
</code></pre>
<p>This is the <strong>only</strong> interface plugins use to access QNTX.</p>
<h2>Consequences</h2>
<h3>Positive</h3>
<p>✅ <strong>Decoupling</strong>: Plugins can be added/removed without affecting others
✅ <strong>Async by default</strong>: Database acts as durable message queue
✅ <strong>Consistency</strong>: Database transactions provide ACID guarantees
✅ <strong>Queryable</strong>: Ax query language works across all plugin data
✅ <strong>Audit trail</strong>: All plugin interactions are attestations (queryable history)</p>
<h3>Negative</h3>
<p>⚠️ <strong>Latency</strong>: Database round-trip slower than direct method calls
⚠️ <strong>Complexity</strong>: Developers must think in events/attestations, not procedure calls
⚠️ <strong>Polling</strong>: Plugins may need to poll for new attestations (mitigated by Pulse jobs)</p>
<h3>Neutral</h3>
<ul>
<li>Attestation schema is flexible (JSON payload) but requires documentation</li>
<li>Database is single point of contention (mitigated by SQLite write-ahead log)</li>
</ul>
<h2>Examples</h2>
<h3>Example 1: Git Ingestion → Code Analysis</h3>
<pre><code class="language-go">// 1. Code plugin ingests git repo
store.Create(ctx, &amp;types.As{
    Actor:   "ixgest-git@user",
    Context: "repository_cloned",
    Entity:  "github.com/teranos/QNTX",
    Payload: json.RawMessage(`{"path": "/tmp/qntx", "branch": "main"}`),
})

// 2. Pulse job monitors for new repos and triggers analysis
// (This could be a scheduled job or a separate plugin watching attestations)

// 3. Analysis results also stored as attestations
store.Create(ctx, &amp;types.As{
    Actor:   "code-analyzer@system",
    Context: "repository_analyzed",
    Entity:  "github.com/teranos/QNTX",
    Payload: json.RawMessage(`{"files": 250, "loc": 45000, "complexity": 3.2}`),
})
</code></pre>
<h3>Example 2: Cross-Domain Dependency</h3>
<p>Finance plugin wants to analyze code complexity:</p>
<pre><code class="language-go">// Finance plugin queries code plugin's attestations
filter := &amp;types.AxFilter{
    Actor:   ptr("code-analyzer@system"),
    Context: ptr("repository_analyzed"),
    Entity:  ptr("github.com/teranos/QNTX"),
}

results, err := store.Query(ctx, filter)
// Parse results[0].Payload to get complexity metrics
</code></pre>
<p>No code→finance dependency, finance reads code's public data (attestations).</p>
<h2>Alternatives Considered</h2>
<h3>Direct Service Registry Access</h3>
<ul>
<li><strong>Rejected</strong>: Tight coupling, breaks process isolation</li>
</ul>
<h3>Event Bus (Redis Pub/Sub)</h3>
<ul>
<li><strong>Rejected</strong>: Adds external dependency, harder to query event history</li>
</ul>
<h3>gRPC Direct Calls</h3>
<ul>
<li><strong>Rejected</strong>: Creates version coupling, harder to evolve plugins independently</li>
</ul>
<h3>Shared In-Memory Cache</h3>
<ul>
<li><strong>Rejected</strong>: Doesn't work with process-isolated plugins</li>
</ul>
<h2>Related</h2>
<ul>
<li><a href="./ADR-001-domain-plugin-architecture.html">ADR-001: Domain Plugin Architecture</a></li>
<li><a href="../../README.md#attestation-system">Attestation System Documentation</a></li>
<li><a href="../../pulse/README.html">Pulse Job System</a></li>
</ul>
<footer class="site-footer">
  <p class="provenance">Generated by sitegen.nix at commit <a href="https://github.com/teranos/QNTX/commit/b664e41fac56a47a886ef727bc4342996b929f1d-dirty">b664e41-dirty</a></p>
</footer>
</body>
</html>
