<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QNTX - nix-development</title>
  <link rel="icon" type="image/jpeg" href="./qntx.jpg">
  <link rel="stylesheet" href="./css/core.css">
  <link rel="stylesheet" href="./css/docs.css">
</head>
<body>
<nav class="doc-nav">
  <a href="./index.html">
    <img src="./qntx.jpg" alt="QNTX" class="site-logo">Documentation Home
  </a>
</nav>
<h1>Nix Development Guide</h1>
<p><strong>Why Nix?</strong> Eliminates "works on my machine" by pinning every dependency - from Go version to system libraries - in a single file. Build today, rebuild in 5 years, get identical binaries.</p>
<p><strong>When to use:</strong></p>
<ul>
<li>Building Docker images for multi-arch (auto-handles arm64/amd64)</li>
<li>Verifying reproducible builds before CI</li>
<li>Quick environment setup without installing Go/Rust locally</li>
</ul>
<p><strong>When not to use:</strong></p>
<ul>
<li>Rapid iteration (local Go build is faster)</li>
<li>Network-dependent operations (Nix sandbox blocks network)</li>
</ul>
<h2>Quick Start</h2>
<h3>Prerequisites</h3>
<ul>
<li>Nix with flakes enabled (install from https://nixos.org/download.html)</li>
<li>Docker (for container image operations)</li>
<li>Git</li>
</ul>
<h3>Development Workflow</h3>
<pre><code class="language-bash"># Enter development shell (installs all dependencies)
nix develop

# Pre-commit hooks are automatically installed in Nix shell
# They include: nixpkgs-fmt for Nix formatting

# Build QNTX binary
nix build

# Build CI container image (defaults to your architecture)
nix build .#ci-image

# Build specific architecture
nix build .#ci-image-amd64
nix build .#ci-image-arm64

# Run checks (flake validation, build verification)
nix flake check
</code></pre>
<h3>Local Git Hooks</h3>
<p>For local development outside the Nix shell, install local Git hooks:</p>
<pre><code class="language-bash">git config core.hooksPath .githooks
</code></pre>
<p>This enables:</p>
<ul>
<li><strong>pre-commit</strong>: Automatic Go code formatting with <code>gofmt</code></li>
<li><strong>post-checkout</strong>: Auto-pull when checking out main branch</li>
</ul>
<p>See <code>.githooks/README.md</code> for details.</p>
<h2>How CI Builds Work</h2>
<p><strong>Why reproducible builds?</strong> Proves the binary you download matches what CI built. Rebuild the same commit later → identical SHA256 hash. No hidden changes.</p>
<p><strong>How it works:</strong></p>
<ol>
<li>Tag a version → triggers <code>.github/workflows/nix-image.yml</code></li>
<li>Builds amd64 + arm64 in parallel (Nix handles cross-compilation)</li>
<li>Rebuilds each architecture twice, verifies hashes match (catches non-determinism)</li>
<li>Pushes to Cachix (binary cache) so future builds are instant</li>
<li>Creates Docker multi-arch manifest (one tag works on all platforms)</li>
</ol>
<p><strong>Why Cachix?</strong> First build takes ~30 min (compiles everything). Cachix caches binaries. Next build: ~5 min (just downloads from cache).</p>
<p><strong>Caching strategy:</strong></p>
<ul>
<li>Cache key: <code>flake.lock</code> hash (nixpkgs version)</li>
<li>Change <code>flake.lock</code> → rebuild everything (new cache key)</li>
<li>Don't change <code>flake.lock</code> → instant downloads from Cachix</li>
</ul>
<h2>Common Tasks</h2>
<h3>Updating Go Dependencies</h3>
<p><strong>Why vendorHash?</strong> Nix downloads your Go modules during build. Hash proves you got what you expected (security). Wrong hash = build fails.</p>
<p><strong>How to update:</strong></p>
<pre><code class="language-bash"># After changing go.mod/go.sum, run this:
./.githooks/update-nix-hash.sh

# Or manually: let it fail, copy new hash from error
nix build .#qntx  # Fails with "got: sha256-ABC..."
# Copy "got" hash to vendorHash in flake.nix

# Verify
nix build .#qntx

# Commit together
git add flake.nix go.mod go.sum
</code></pre>
<h3>Upgrading Nixpkgs</h3>
<p><strong>Why upgrade?</strong> Get newer Go/Rust versions, security patches, bug fixes in build tools.</p>
<p><strong>When to upgrade?</strong> Monthly, or when you need a specific package version.</p>
<pre><code class="language-bash">nix flake update nixpkgs  # Updates flake.lock
nix build .#qntx          # Test build still works
nix flake check           # Verify all packages build

git add flake.lock
git commit -m "Update nixpkgs"
</code></pre>
<p><strong>Warning:</strong> This invalidates Cachix cache (new packages = rebuild everything once).</p>
<h3>Adding System Dependencies to Docker Image</h3>
<p><strong>When needed:</strong> CI tests require a new CLI tool (e.g., <code>jq</code> for JSON processing).</p>
<p><strong>How to add:</strong></p>
<ol>
<li>Edit <code>flake.nix</code> → find <code>mkCiImage</code> function → add to <code>contents = [...]</code></li>
<li>If binary needs to be in PATH, add to <code>config.Env</code> PATH list</li>
<li>Test: <code>nix build .#ci-image &amp;&amp; docker load &lt; result</code></li>
</ol>
<p><strong>Example:</strong> Adding <code>jq</code>:</p>
<pre><code class="language-nix">contents = [
  qntx
  pkgs.jq  # Add this
  # ...
];

config.Env = [
  "PATH=${pkgs.lib.makeBinPath [ qntx pkgs.jq ... ]}"  # Add to PATH
];
</code></pre>
<h2>Nix vs Local Development</h2>
<h3>Nix Shell</h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Consistent versions across team</li>
<li>Automatic pre-commit hooks (nixpkgs-fmt)</li>
<li>Reproducible environment</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Sandbox restrictions (no network access for some hooks)</li>
<li>Slower first-time setup</li>
</ul>
<p><strong>When to use:</strong></p>
<ul>
<li>CI validation before pushing</li>
<li>Ensuring reproducible builds</li>
<li>Nix formatting checks</li>
</ul>
<h3>Local Git Hooks</h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Fast (no sandbox)</li>
<li>Network access (Go module downloads)</li>
<li>Instant feedback</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires local Go installation</li>
<li>Not enforced automatically</li>
</ul>
<p><strong>When to use:</strong></p>
<ul>
<li>Day-to-day development</li>
<li>Quick formatting before commits</li>
<li>When working offline with cached modules</li>
</ul>
<p><strong>Setup:</strong></p>
<pre><code class="language-bash">git config core.hooksPath .githooks
</code></pre>
<h2>Troubleshooting</h2>
<h3>"Hash mismatch for vendor derivation"</h3>
<p><strong>Why:</strong> Nix hashes your Go modules to detect tampering. You changed <code>go.mod</code> but didn't update the hash → security check fails.</p>
<p><strong>Fix:</strong> <code>./.githooks/update-nix-hash.sh</code> or copy "got:" hash from error to <code>flake.nix</code>.</p>
<h3>"Network access not allowed"</h3>
<p><strong>Why:</strong> Nix sandbox blocks network to force reproducibility. Can't download during build → must declare all deps upfront.</p>
<p><strong>Fix:</strong> Update vendorHash (Go deps) or add to <code>contents = [...]</code> (system deps).</p>
<h3>CI build fails, local succeeds</h3>
<p><strong>Why:</strong> You're on different nixpkgs version. CI uses <code>flake.lock</code>, you might have uncommitted <code>flake.lock</code>.</p>
<p><strong>Fix:</strong> <code>git add flake.lock</code> and commit it. Or <code>nix flake update</code> to match CI.</p>
<h2>Workflow Recommendations</h2>
<p><strong>Daily development:</strong></p>
<ul>
<li>Use local Go build (<code>make cli</code>) for speed</li>
<li>Use local git hooks (<code>git config core.hooksPath .githooks</code>) for instant formatting</li>
<li>Save Nix for final validation before push</li>
</ul>
<p><strong>Before pushing:</strong></p>
<ul>
<li>Run <code>nix flake check</code> to catch Nix-specific breakage</li>
<li>If you changed <code>go.mod</code>: run <code>./.githooks/update-nix-hash.sh</code></li>
<li>Commit <code>flake.lock</code> when modified (ensures CI matches your build)</li>
</ul>
<p><strong>Monthly maintenance:</strong></p>
<ul>
<li><code>nix flake update</code> to get latest packages (security patches, Go version bumps)</li>
<li>Invalidates Cachix → first CI build will be slow, subsequent ones fast again</li>
</ul>
<p><strong>After tagging:</strong></p>
<ul>
<li>Always watch CI pipeline (both architectures must succeed)</li>
<li>Don't retag on failure - increment patch version instead (preserves history)</li>
</ul>
<h2>Resources</h2>
<ul>
<li><a href="https://nixos.wiki/wiki/Flakes">Nix Flakes</a></li>
<li><a href="https://nixos.org/manual/nixpkgs/stable/">nixpkgs manual</a></li>
<li><a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-dockerTools">Nix Docker Images</a></li>
<li><a href="https://github.com/cachix/install-nix-action">GitHub Actions Nix</a></li>
</ul>
<h2>Related Documentation</h2>
<ul>
<li><code>.githooks/README.md</code> - Local Git hooks setup</li>
<li><code>flake.nix</code> - Nix configuration source of truth</li>
<li><code>.github/workflows/nix-image.yml</code> - CI pipeline definition</li>
</ul>
<footer class="site-footer">
  <p class="provenance">Generated by sitegen.nix at commit <a href="https://github.com/teranos/QNTX/commit/b664e41fac56a47a886ef727bc4342996b929f1d-dirty">b664e41-dirty</a></p>
</footer>
</body>
</html>
