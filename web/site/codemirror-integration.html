<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QNTX - codemirror-integration</title>
  <link rel="icon" type="image/jpeg" href="./qntx.jpg">
  <link rel="stylesheet" href="./css/core.css">
  <link rel="stylesheet" href="./css/docs.css">
</head>
<body>
<nav class="doc-nav">
  <a href="./index.html">
    <img src="./qntx.jpg" alt="QNTX" class="site-logo">Documentation Home
  </a>
</nav>
<h1>CodeMirror 6 Integration Reference</h1>
<p><strong>Context</strong>: Reference guide for CodeMirror 6 concepts relevant to QNTX ATS query editor implementation.</p>
<p><strong>Related</strong>: Issue #13 - Track codemirror-languageserver semantic token support</p>
<h2>Core CodeMirror 6 Concepts</h2>
<h3>1. State + View Architecture</h3>
<p><strong>EditorState</strong> - Immutable document state:</p>
<ul>
<li>Document content</li>
<li>Selection/cursor position</li>
<li>Extensions configuration</li>
<li>All state is immutable</li>
</ul>
<p><strong>EditorView</strong> - DOM rendering and event handling:</p>
<ul>
<li>Renders the state</li>
<li>Handles user interactions</li>
<li>Dispatches transactions to update state</li>
</ul>
<p><strong>Pattern</strong>:</p>
<pre><code class="language-javascript">// State → View → User interaction → Transaction → New State
const state = EditorState.create({doc: "initial text"})
const view = new EditorView({state, parent: container})

// Updates are transactions
view.dispatch({
  changes: {from: 0, to: 5, insert: "Hello"}
})
</code></pre>
<h3>2. Extensions System</h3>
<p>Everything in CodeMirror 6 is an extension - features are composable plugins:</p>
<pre><code class="language-javascript">import { lineNumbers } from '@codemirror/view'
import { highlightActiveLineGutter } from '@codemirror/view'

EditorState.create({
  extensions: [
    lineNumbers(),                    // Built-in
    highlightActiveLineGutter(),       // Built-in
    myCustomExtension(),               // Custom
  ]
})
</code></pre>
<p><strong>Common extension types</strong>:</p>
<ul>
<li>State extensions (keymaps, themes)</li>
<li>View plugins (decorations, event handlers)</li>
<li>Facets (configuration points)</li>
</ul>
<h3>3. Decorations for Styling</h3>
<p>Replace custom DOM manipulation with CodeMirror decorations:</p>
<p><strong>Mark decorations</strong> - Wrap text ranges:</p>
<pre><code class="language-javascript">Decoration.mark({class: "cm-keyword"}).range(from, to)
</code></pre>
<p><strong>Widget decorations</strong> - Insert DOM elements:</p>
<pre><code class="language-javascript">Decoration.widget({
  widget: new MyWidgetClass(),
  side: 1  // After position
}).range(pos)
</code></pre>
<p><strong>Line decorations</strong> - Style entire lines:</p>
<pre><code class="language-javascript">Decoration.line({class: "cm-error-line"}).range(pos)
</code></pre>
<h3>4. Transactions are Immutable</h3>
<p>Never mutate <code>view.state</code> directly:</p>
<pre><code class="language-javascript">// ❌ Wrong - direct mutation
view.state.doc = newDoc

// ✅ Correct - dispatch transaction
view.dispatch({
  changes: {from: 0, to: view.state.doc.length, insert: newDoc}
})
</code></pre>
<h3>5. StateField for Custom State</h3>
<p>Store extension-specific state that persists across transactions:</p>
<pre><code class="language-javascript">import { StateField, StateEffect } from '@codemirror/state'

// Define effect for state updates
const updateDecorations = StateEffect.define()

// StateField holds decorations
const syntaxDecorations = StateField.define({
  create() {
    return Decoration.none
  },
  update(value, tr) {
    // Apply effects from transaction
    for (let effect of tr.effects) {
      if (effect.is(updateDecorations)) {
        return effect.value
      }
    }
    return value
  },
  provide: f =&gt; EditorView.decorations.from(f)
})
</code></pre>
<h2>LSP Integration with CodeMirror</h2>
<h3>languageServer() Extension</h3>
<p>The <code>@codemirror/language-server</code> package provides LSP client:</p>
<pre><code class="language-javascript">import { languageServer } from '@codemirror/language-server'

const lspExtension = languageServer({
  serverUri: 'ws://localhost:877/lsp',
  rootUri: 'file:///',
  documentUri: 'file:///query.ats',
  languageId: 'ats',
})
</code></pre>
<p><strong>Provides</strong>:</p>
<ul>
<li><code>textDocument/completion</code> → Native completion UI</li>
<li><code>textDocument/hover</code> → Hover tooltips</li>
<li><code>textDocument/publishDiagnostics</code> → Error squiggles</li>
</ul>
<h3>Current Limitation (Issue #13)</h3>
<p><code>@codemirror/language-server</code> <strong>does not yet support semantic tokens</strong> (as of v1.18.1).</p>
<p><strong>Workaround</strong>: QNTX uses custom <code>parse_request</code>/<code>parse_response</code> WebSocket protocol:</p>
<ul>
<li>Server sends semantic tokens via custom protocol</li>
<li>Client applies decorations manually via StateField</li>
<li>When library adds support, migrate to standard <code>textDocument/semanticTokens/full</code></li>
</ul>
<h2>Migration Strategy (from Custom Protocol)</h2>
<h3>Current Architecture</h3>
<pre><code>CodeMirror 6 Editor
  ├─ languageServer() extension → /lsp (completions, hover)
  └─ Custom WebSocket → /ws (semantic tokens via parse_request)
</code></pre>
<h3>Target Architecture (when Issue #13 resolved)</h3>
<pre><code>CodeMirror 6 Editor
  └─ languageServer() extension → /lsp (completions, hover, semantic tokens)
</code></pre>
<h2>References</h2>
<ul>
<li>CodeMirror 6 Docs: https://codemirror.net/docs/</li>
<li>@codemirror/language-server: https://github.com/FurqanSoftware/codemirror-languageserver</li>
<li>Issue #13: Track codemirror-languageserver semantic token support</li>
</ul>
<footer class="site-footer">
  <p class="provenance">Generated by sitegen.nix at commit <a href="https://github.com/teranos/QNTX/commit/0e7ca38dd1dcce5d67e9797b91950b21353f137a-dirty">0e7ca38-dirty</a></p>
</footer>
</body>
</html>
