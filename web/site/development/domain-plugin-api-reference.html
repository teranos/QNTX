<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QNTX - domain-plugin-api-reference</title>
  <link rel="icon" type="image/jpeg" href="../qntx.jpg">
  <link rel="stylesheet" href="../css/core.css">
  <link rel="stylesheet" href="../css/docs.css">
</head>
<body>
<nav class="doc-nav">
  <a href="../index.html">
    <img src="../qntx.jpg" alt="QNTX" class="site-logo">Documentation Home
  </a>
</nav>
<h1>Domain Plugin API Reference</h1>
<p>Complete reference for the DomainPlugin interface and ServiceRegistry.</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#domainplugin-interface">DomainPlugin Interface</a></li>
<li><a href="#serviceregistry-interface">ServiceRegistry Interface</a></li>
<li><a href="#plugin-lifecycle">Plugin Lifecycle</a></li>
<li><a href="#http-handlers">HTTP Handlers</a></li>
<li><a href="#websocket-handlers">WebSocket Handlers</a></li>
<li><a href="#cli-commands">CLI Commands</a></li>
<li><a href="#error-handling">Error Handling</a></li>
</ul>
<h2>DomainPlugin Interface</h2>
<pre><code class="language-go">package domains

import (
    "context"
    "net/http"

    "github.com/spf13/cobra"
)

type DomainPlugin interface {
    // Metadata returns plugin information
    Metadata() Metadata

    // Initialize prepares the plugin for use
    Initialize(ctx context.Context, services ServiceRegistry) error

    // Shutdown cleans up plugin resources
    Shutdown(ctx context.Context) error

    // Commands returns CLI commands for this domain
    Commands() []*cobra.Command

    // RegisterHTTP registers HTTP handlers for this domain
    RegisterHTTP(mux *http.ServeMux) error

    // RegisterWebSocket registers WebSocket handlers for this domain
    RegisterWebSocket() (map[string]WebSocketHandler, error)

    // Health returns current health status
    Health(ctx context.Context) HealthStatus
}
</code></pre>
<h3>Metadata</h3>
<p>Returns plugin identification and version information.</p>
<pre><code class="language-go">type Metadata struct {
    Name        string // Plugin name (lowercase, e.g., "code")
    Version     string // Plugin version (semver, e.g., "0.1.0")
    QNTXVersion string // Required QNTX version (semver constraint, e.g., "&gt;= 0.1.0")
    Description string // Human-readable description
    Author      string // Author or organization
    License     string // License (e.g., "MIT", "Apache-2.0")
}
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) Metadata() domains.Metadata {
    return domains.Metadata{
        Name:        "code",
        Version:     "0.1.0",
        QNTXVersion: "&gt;= 0.1.0",
        Description: "Software development domain (git, GitHub, gopls, code editor)",
        Author:      "QNTX Team",
        License:     "MIT",
    }
}
</code></pre>
<p><strong>Version Validation</strong>:</p>
<ul>
<li>Registry validates <code>QNTXVersion</code> constraint using <a href="https://github.com/Masterminds/semver">Masterminds/semver</a></li>
<li>Plugin fails to register if QNTX version doesn't satisfy constraint</li>
<li>Use <code>&gt;= X.Y.Z</code> for minimum version, <code>~X.Y.Z</code> for patch-level compatibility</li>
</ul>
<h3>Initialize</h3>
<p>Called once during server startup. Plugins receive services and prepare for use.</p>
<pre><code class="language-go">func (p *Plugin) Initialize(ctx context.Context, services ServiceRegistry) error
</code></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>ctx</code>: Cancellation context (server shutdown triggers cancellation)</li>
<li><code>services</code>: Interface to QNTX core services (DB, logger, config, ATS store)</li>
</ul>
<p><strong>Responsibilities</strong>:</p>
<ol>
<li>Store <code>services</code> reference for later use</li>
<li>Load configuration via <code>services.Config()</code></li>
<li>Initialize domain-specific resources (connections, caches, etc.)</li>
<li>Validate requirements (API tokens, workspace paths, etc.)</li>
</ol>
<p><strong>Return</strong>:</p>
<ul>
<li><code>nil</code> on success</li>
<li><code>error</code> on failure (server will refuse to start - fail-fast policy)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) Initialize(ctx context.Context, services ServiceRegistry) error {
    p.services = services
    logger := services.Logger("code")

    config := services.Config("code")
    workspace := config.GetString("gopls.workspace_root")
    if workspace == "" {
        workspace = "."
    }

    // Initialize gopls language server
    goplsService, err := gopls.NewService(gopls.Config{
        WorkspaceRoot: workspace,
        Logger:        logger,
    })
    if err != nil {
        return fmt.Errorf("failed to initialize gopls: %w", err)
    }

    if err := goplsService.Initialize(ctx); err != nil {
        return fmt.Errorf("gopls initialization failed: %w", err)
    }

    p.goplsService = goplsService
    logger.Info("Code domain plugin initialized")

    return nil
}
</code></pre>
<h3>Shutdown</h3>
<p>Called during graceful server shutdown. Clean up resources.</p>
<pre><code class="language-go">func (p *Plugin) Shutdown(ctx context.Context) error
</code></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>ctx</code>: Shutdown deadline context (typically 30s timeout)</li>
</ul>
<p><strong>Responsibilities</strong>:</p>
<ol>
<li>Close connections (DB clients, API connections)</li>
<li>Stop background goroutines</li>
<li>Flush pending writes</li>
<li>Release file handles</li>
</ol>
<p><strong>Return</strong>:</p>
<ul>
<li><code>nil</code> on success</li>
<li><code>error</code> logged but shutdown continues</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) Shutdown(ctx context.Context) error {
    if p.services != nil {
        logger := p.services.Logger("code")
        logger.Info("Code domain plugin shutting down")
    }

    // Stop gopls language server
    if p.goplsService != nil {
        if err := p.goplsService.Shutdown(ctx); err != nil {
            return fmt.Errorf("gopls shutdown failed: %w", err)
        }
    }

    return nil
}
</code></pre>
<h3>Commands</h3>
<p>Returns CLI commands for this domain. Commands are automatically registered under <code>qntx &lt;domain&gt;</code>.</p>
<pre><code class="language-go">func (p *Plugin) Commands() []*cobra.Command
</code></pre>
<p><strong>Return</strong>:</p>
<ul>
<li>Slice of <code>*cobra.Command</code> (typically one root command with subcommands)</li>
</ul>
<p><strong>Conventions</strong>:</p>
<ul>
<li>Root command: <code>qntx &lt;domain&gt;</code> (e.g., <code>qntx code</code>)</li>
<li>Subcommands: <code>qntx &lt;domain&gt; &lt;feature&gt;</code> (e.g., <code>qntx code ix git</code>)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) Commands() []*cobra.Command {
    // Root command for code domain
    codeCmd := &amp;cobra.Command{
        Use:   "code",
        Short: "Software development tools",
        Long:  "Code domain provides git ingestion, GitHub integration, language servers, and code editing",
    }

    // IX subcommand group
    ixCmd := &amp;cobra.Command{
        Use:   "ix",
        Short: "Data ingestion commands",
    }
    ixCmd.AddCommand(p.buildIxGitCommand())
    codeCmd.AddCommand(ixCmd)

    return []*cobra.Command{codeCmd}
}

func (p *Plugin) buildIxGitCommand() *cobra.Command {
    return &amp;cobra.Command{
        Use:   "git &lt;repository-url&gt;",
        Short: "Ingest git repository",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error {
            // Implementation
            return nil
        },
    }
}
</code></pre>
<h3>RegisterHTTP</h3>
<p>Registers HTTP handlers for this domain. Routes must be namespaced under <code>/api/&lt;domain&gt;/</code>.</p>
<pre><code class="language-go">func (p *Plugin) RegisterHTTP(mux *http.ServeMux) error
</code></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>mux</code>: HTTP request multiplexer (plugin-specific, not global)</li>
</ul>
<p><strong>Route Constraints</strong>:</p>
<ul>
<li>All routes MUST start with <code>/api/&lt;domain&gt;/</code></li>
<li>Example: <code>/api/code/</code>, <code>/api/code/github/pr</code></li>
<li><strong>Enforcement</strong>: Routes outside namespace will be rejected in future versions</li>
</ul>
<p><strong>Return</strong>:</p>
<ul>
<li><code>nil</code> on success</li>
<li><code>error</code> if registration fails</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) RegisterHTTP(mux *http.ServeMux) error {
    // Code file tree and content
    mux.HandleFunc("/api/code", p.handleCodeTree)
    mux.HandleFunc("/api/code/", p.handleCodeContent)

    // GitHub integration
    mux.HandleFunc("/api/code/github/pr/", p.handlePRSuggestions)
    mux.HandleFunc("/api/code/github/pr", p.handlePRList)

    return nil
}

func (p *Plugin) handleCodeTree(w http.ResponseWriter, r *http.Request) {
    logger := p.services.Logger("code")

    if r.Method != http.MethodGet {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    tree, err := p.buildCodeTree()
    if err != nil {
        logger.Errorw("Failed to build code tree", "error", err)
        http.Error(w, "Failed to load code tree", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(tree)
}
</code></pre>
<p><strong>Security Best Practices</strong>:</p>
<ol>
<li><strong>Path validation</strong>: Always validate user-provided paths</li>
<li><strong>Error logging</strong>: Log errors with context before returning generic HTTP errors</li>
<li><strong>Dev mode checks</strong>: Restrict dangerous operations (file writes) to dev mode</li>
</ol>
<h3>RegisterWebSocket</h3>
<p>Registers WebSocket handlers for real-time features.</p>
<pre><code class="language-go">func (p *Plugin) RegisterWebSocket() (map[string]WebSocketHandler, error)
</code></pre>
<p><strong>Return</strong>:</p>
<ul>
<li><code>map[string]WebSocketHandler</code>: Path → handler mapping</li>
<li><code>error</code> if registration fails</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) RegisterWebSocket() (map[string]domains.WebSocketHandler, error) {
    handlers := make(map[string]domains.WebSocketHandler)

    // Language server protocol endpoint
    handlers["/gopls"] = p.handleGoplsWebSocket

    return handlers, nil
}

type WebSocketHandler func(conn *websocket.Conn) error

func (p *Plugin) handleGoplsWebSocket(conn *websocket.Conn) error {
    // Handle LSP messages via WebSocket
    return p.goplsService.HandleConnection(conn)
}
</code></pre>
<p><strong>Note</strong>: WebSocket integration is planned but not yet wired into server (tracked in issue #127).</p>
<h3>Health</h3>
<p>Returns current plugin health status for monitoring.</p>
<pre><code class="language-go">func (p *Plugin) Health(ctx context.Context) HealthStatus
</code></pre>
<p><strong>Return</strong>:</p>
<pre><code class="language-go">type HealthStatus struct {
    Healthy bool                   // Overall health
    Message string                 // Human-readable status
    Details map[string]interface{} // Component-specific details
}
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) Health(ctx context.Context) domains.HealthStatus {
    details := make(map[string]interface{})

    // Check gopls service
    if p.goplsService != nil {
        if err := p.goplsService.Ping(ctx); err != nil {
            return domains.HealthStatus{
                Healthy: false,
                Message: "gopls service unavailable",
                Details: map[string]interface{}{
                    "gopls_error": err.Error(),
                },
            }
        }
        details["gopls"] = "ok"
    }

    // Check database access
    db := p.services.Database()
    if err := db.PingContext(ctx); err != nil {
        return domains.HealthStatus{
            Healthy: false,
            Message: "database connection failed",
            Details: map[string]interface{}{
                "db_error": err.Error(),
            },
        }
    }
    details["database"] = "ok"

    return domains.HealthStatus{
        Healthy: true,
        Message: "Code domain operational",
        Details: details,
    }
}
</code></pre>
<h2>ServiceRegistry Interface</h2>
<p>Plugins access QNTX services via <code>ServiceRegistry</code> interface.</p>
<pre><code class="language-go">type ServiceRegistry interface {
    Database() *sql.DB
    Logger(domain string) *zap.SugaredLogger
    Config(domain string) Config
    ATSStore() *storage.SQLStore
    Queue() *async.Queue
}
</code></pre>
<h3>Database()</h3>
<p>Returns direct SQL database connection.</p>
<pre><code class="language-go">func (s ServiceRegistry) Database() *sql.DB
</code></pre>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Custom queries beyond ATS store</li>
<li>Bulk operations</li>
<li>Schema migrations (plugins can create their own tables)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">func (p *Plugin) storeCustomData(ctx context.Context, data string) error {
    db := p.services.Database()

    _, err := db.ExecContext(ctx, `
        INSERT INTO plugin_code_cache (key, value, created_at)
        VALUES (?, ?, ?)
    `, "cache_key", data, time.Now())

    return err
}
</code></pre>
<h3>Logger(domain string)</h3>
<p>Returns domain-scoped structured logger.</p>
<pre><code class="language-go">func (s ServiceRegistry) Logger(domain string) *zap.SugaredLogger
</code></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>domain</code>: Plugin domain name (usually plugin's own name)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">logger := p.services.Logger("code")
logger.Infow("Processing repository", "url", repoURL, "branch", "main")
logger.Errorw("Failed to clone", "url", repoURL, "error", err)
</code></pre>
<h3>Config(domain string)</h3>
<p>Returns domain-specific configuration.</p>
<pre><code class="language-go">func (s ServiceRegistry) Config(domain string) Config

type Config interface {
    GetString(key string) string
    GetInt(key string) int
    GetBool(key string) bool
    GetStringSlice(key string) []string
    Get(key string) interface{}
    Set(key string, value interface{})
}
</code></pre>
<p><strong>Configuration File</strong>: <code>am.&lt;domain&gt;.toml</code></p>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">config := p.services.Config("code")

workspace := config.GetString("gopls.workspace_root")  // Reads am.code.toml
enabled := config.GetBool("gopls.enabled")
maxSize := config.GetInt("editor.max_file_size_mb")
</code></pre>
<h3>ATSStore()</h3>
<p>Returns attestation storage interface (CRUD for attestations).</p>
<pre><code class="language-go">func (s ServiceRegistry) ATSStore() *storage.SQLStore
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">store := p.services.ATSStore()

// Create attestation
attestation := &amp;types.As{
    Actor:   "ixgest-git@user",
    Context: "repository_ingested",
    Entity:  "github.com/teranos/QNTX",
    Payload: json.RawMessage(`{"commit_count": 150}`),
}
err := store.Create(ctx, attestation)

// Query attestations
filter := &amp;types.AxFilter{
    Context: ptr("repository_ingested"),
}
results, err := store.Query(ctx, filter)
</code></pre>
<h3>Queue()</h3>
<p>Returns the Pulse async job queue for enqueueing background jobs.</p>
<pre><code class="language-go">func (s ServiceRegistry) Queue() *async.Queue
</code></pre>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Queue long-running operations (git ingestion, analysis tasks)</li>
<li>Defer work to background workers with progress tracking</li>
<li>Integrate with Pulse job system instead of direct database manipulation</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-go">queue := p.services.Queue()

// Create job
job := &amp;async.Job{
    ID:          fmt.Sprintf("job_%d", time.Now().UnixNano()),
    HandlerName: "ixgest.git",
    Payload:     payloadJSON,
    Source:      fmt.Sprintf("cli:ix-git:%s", repoURL),
    Status:      async.JobStatusQueued,
    Progress: async.Progress{
        Current: 0,
        Total:   100,
    },
    CreatedAt: time.Now(),
    UpdatedAt: time.Now(),
}

// Enqueue job via Pulse API
if err := queue.Enqueue(job); err != nil {
    return fmt.Errorf("failed to queue job: %w", err)
}
</code></pre>
<p><strong>Important</strong>: Always use <code>Queue()</code> instead of direct SQL manipulation of <code>pulse_jobs</code> table. This ensures proper job lifecycle management, subscriber notifications, and integration with the Pulse system.</p>
<h2>Plugin Lifecycle</h2>
<pre><code>Server Startup:
  1. Registry.InitializeAll()
  2. For each plugin (sorted by name):
     a. plugin.Initialize(ctx, services)
     b. If error: panic (fail-fast)
  3. plugin.RegisterHTTP(mux)
  4. plugin.Commands() → registered with CLI

Server Running:
  - Plugins handle HTTP/WebSocket requests
  - Plugins execute CLI commands
  - Plugin errors broadcast to UI (no crash)

Server Shutdown:
  1. Registry.ShutdownAll()
  2. For each plugin (reverse order):
     a. plugin.Shutdown(ctx)
     b. Log errors but continue
</code></pre>
<h2>Error Handling</h2>
<h3>Initialization Errors</h3>
<pre><code class="language-go">// Fail-fast: Return error, server won't start
func (p *Plugin) Initialize(ctx context.Context, services ServiceRegistry) error {
    if critical := p.validateCriticalConfig(); critical != nil {
        return fmt.Errorf("missing critical config: %w", critical)
    }

    // Graceful degradation: Log warning, feature disabled
    if optional := p.initOptionalFeature(); optional != nil {
        logger.Warnw("Optional feature disabled", "error", optional)
        p.optionalFeature = nil  // Feature remains disabled
    }

    return nil
}
</code></pre>
<h3>Runtime Errors</h3>
<pre><code class="language-go">// HTTP handler errors: Log with context, return generic error
func (p *Plugin) handleRequest(w http.ResponseWriter, r *http.Request) {
    logger := p.services.Logger("code")

    result, err := p.processRequest(r)
    if err != nil {
        logger.Errorw("Request processing failed",
            "path", r.URL.Path,
            "method", r.Method,
            "error", err,
        )
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }

    json.NewEncoder(w).Encode(result)
}
</code></pre>
<h2>Complete Example</h2>
<p>The <code>code</code> domain plugin provides a full reference implementation demonstrating all API methods and best practices.</p>
<footer class="site-footer">
  <p class="provenance">Generated by sitegen.nix at commit <a href="https://github.com/teranos/QNTX/commit/0e7ca38dd1dcce5d67e9797b91950b21353f137a-dirty">0e7ca38-dirty</a></p>
</footer>
</body>
</html>
