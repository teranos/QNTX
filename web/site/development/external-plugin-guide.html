<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QNTX - external-plugin-guide</title>
  <link rel="icon" type="image/jpeg" href="../qntx.jpg">
  <link rel="stylesheet" href="../css/core.css">
  <link rel="stylesheet" href="../css/docs.css">
</head>
<body>
<nav class="doc-nav">
  <a href="../index.html">
    <img src="../qntx.jpg" alt="QNTX" class="site-logo">Documentation Home
  </a>
</nav>
<h1>External Plugin Development Guide</h1>
<p>This guide explains how to develop external QNTX domain plugins that run as separate processes and communicate via gRPC. For the complete gRPC API reference, see <a href="../api/grpc-plugin.html">Plugin gRPC API</a>.</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#plugin-structure">Plugin Structure</a></li>
<li><a href="#grpc-protocol">gRPC Protocol</a></li>
<li><a href="#building-and-deploying">Building and Deploying</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#best-practices">Best Practices</a></li>
</ul>
<h2>Overview</h2>
<p>There is <strong>one plugin interface</strong>: <code>DomainPlugin</code>. Both built-in and external plugins implement the same interface:</p>
<ul>
<li><strong>Built-in plugins</strong>: Implement <code>DomainPlugin</code> directly (e.g., <code>code.Plugin</code>)</li>
<li><strong>External plugins</strong>: <code>ExternalDomainProxy</code> implements <code>DomainPlugin</code> by proxying gRPC calls to a sidecar process</li>
</ul>
<p>From the Registry's perspective, there is no difference. This enables:</p>
<ul>
<li><strong>Process isolation</strong>: Plugin crashes don't crash QNTX</li>
<li><strong>Language agnostic</strong>: External plugins can be written in any gRPC-compatible language</li>
<li><strong>Independent deployment</strong>: Update plugins without rebuilding QNTX</li>
<li><strong>Unified API</strong>: Same interface for all plugins</li>
</ul>
<h2>Architecture</h2>
<pre><code>                        ┌─────────────────────────────────────┐
                        │           domains.Registry          │
                        │   (treats all plugins identically)  │
                        └─────────────────────────────────────┘
                                         │
                    ┌────────────────────┼────────────────────┐
                    │                    │                    │
                    ▼                    ▼                    ▼
         ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
         │   code.Plugin    │  │ finance.Plugin   │  │ExternalDomainProxy│
         │   (built-in)     │  │   (built-in)     │  │    (adapter)      │
         │                  │  │                  │  │                   │
         │ implements       │  │ implements       │  │ implements        │
         │ DomainPlugin     │  │ DomainPlugin     │  │ DomainPlugin      │
         └──────────────────┘  └──────────────────┘  └─────────┬─────────┘
                                                               │ gRPC
                                                               ▼
                                                     ┌──────────────────┐
                                                     │  External Plugin │
                                                     │ (sidecar process)│
                                                     │                  │
                                                     │ PluginServer     │
                                                     │ wraps DomainPlugin│
                                                     └──────────────────┘
</code></pre>
<p>The <code>ExternalDomainProxy</code> is simply an adapter that:</p>
<ol>
<li>Implements <code>DomainPlugin</code> interface</li>
<li>Translates method calls to gRPC requests</li>
<li>Sends requests to a sidecar process running <code>PluginServer</code></li>
</ol>
<h2>Quick Start</h2>
<h3>1. Create Plugin Directory</h3>
<pre><code class="language-bash">mkdir my-plugin
cd my-plugin
go mod init github.com/myorg/qntx-myplugin
</code></pre>
<h3>2. Add Dependencies</h3>
<pre><code class="language-bash">go get github.com/teranos/QNTX/plugin
go get github.com/teranos/QNTX/plugin/grpc
go get google.golang.org/grpc
</code></pre>
<h3>3. Implement DomainPlugin Interface</h3>
<pre><code class="language-go">// plugin.go
package main

import (
    "context"
    "net/http"

    "github.com/spf13/cobra"
    "github.com/teranos/QNTX/plugin"
)

type MyPlugin struct {
    services domains.ServiceRegistry
}

func NewMyPlugin() *MyPlugin {
    return &amp;MyPlugin{}
}

func (p *MyPlugin) Metadata() domains.Metadata {
    return domains.Metadata{
        Name:        "myplugin",
        Version:     "1.0.0",
        QNTXVersion: "&gt;= 0.1.0",
        Description: "My custom QNTX plugin",
        Author:      "Your Name",
        License:     "MIT",
    }
}

func (p *MyPlugin) Initialize(ctx context.Context, services domains.ServiceRegistry) error {
    p.services = services
    logger := services.Logger("myplugin")
    logger.Info("MyPlugin initialized")
    return nil
}

func (p *MyPlugin) Shutdown(ctx context.Context) error {
    return nil
}

func (p *MyPlugin) Commands() []*cobra.Command {
    return []*cobra.Command{
        {
            Use:   "myplugin",
            Short: "My plugin commands",
            Run: func(cmd *cobra.Command, args []string) {
                cmd.Println("Hello from MyPlugin!")
            },
        },
    }
}

func (p *MyPlugin) RegisterHTTP(mux *http.ServeMux) error {
    mux.HandleFunc("/api/myplugin/hello", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello from MyPlugin!"))
    })
    return nil
}

func (p *MyPlugin) RegisterWebSocket() (map[string]domains.WebSocketHandler, error) {
    return nil, nil
}

func (p *MyPlugin) Health(ctx context.Context) domains.HealthStatus {
    return domains.HealthStatus{
        Healthy: true,
        Message: "MyPlugin is healthy",
    }
}
</code></pre>
<h3>4. Create Main Entry Point</h3>
<pre><code class="language-go">// main.go
package main

import (
    "context"
    "flag"
    "fmt"
    "os"
    "os/signal"
    "syscall"

    plugingrpc "github.com/teranos/QNTX/plugin/grpc"
    "go.uber.org/zap"
)

var port = flag.Int("port", 9000, "gRPC server port")

func main() {
    flag.Parse()

    logger, _ := zap.NewProduction()
    sugar := logger.Sugar()
    defer logger.Sync()

    plugin := NewMyPlugin()
    server := plugingrpc.NewPluginServer(plugin, sugar)

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    go func() {
        &lt;-sigChan
        cancel()
    }()

    addr := fmt.Sprintf(":%d", *port)
    sugar.Infow("Starting plugin", "address", addr)

    if err := server.Serve(ctx, addr); err != nil {
        sugar.Fatalw("Server error", "error", err)
    }
}
</code></pre>
<h3>5. Build and Run</h3>
<pre><code class="language-bash">go build -o qntx-myplugin .
./qntx-myplugin --port 9001
</code></pre>
<h3>6. Register with QNTX</h3>
<p>The <code>PluginManager</code> loads external plugins and returns <code>DomainPlugin</code> instances that can be registered with the Registry:</p>
<pre><code class="language-go">// In QNTX server initialization
manager := grpc.NewPluginManager(logger)

// Load external plugins from config
configs := []grpc.PluginConfig{
    {Name: "myplugin", Enabled: true, Address: "localhost:9001"},
}
manager.LoadPlugins(ctx, configs)

// Get plugins as DomainPlugin instances and register them
for _, plugin := range manager.GetAllPlugins() {
    registry.Register(plugin)  // Same API as built-in plugins
}
</code></pre>
<p>Or configure via <code>~/.qntx/am.plugins.toml</code>:</p>
<pre><code class="language-toml">[[plugins]]
name = "myplugin"
enabled = true
address = "localhost:9001"
</code></pre>
<p>For auto-start:</p>
<pre><code class="language-toml">[[plugins]]
name = "myplugin"
enabled = true
binary = "qntx-myplugin"
auto_start = true
</code></pre>
<h2>Plugin Structure</h2>
<h3>Recommended Directory Layout</h3>
<pre><code>qntx-myplugin/
├── main.go              # Entry point with gRPC server
├── plugin.go            # DomainPlugin implementation
├── commands.go          # CLI command definitions
├── handlers.go          # HTTP handler implementations
├── go.mod
├── go.sum
├── README.md
└── config/
    └── am.myplugin.toml # Default configuration
</code></pre>
<h3>DomainPlugin Interface</h3>
<p>Every plugin must implement:</p>
<pre><code class="language-go">type DomainPlugin interface {
    Metadata() Metadata
    Initialize(ctx context.Context, services ServiceRegistry) error
    Shutdown(ctx context.Context) error
    Commands() []*cobra.Command
    RegisterHTTP(mux *http.ServeMux) error
    RegisterWebSocket() (map[string]WebSocketHandler, error)
    Health(ctx context.Context) HealthStatus
}
</code></pre>
<h2>gRPC Protocol</h2>
<p>The gRPC protocol is defined in <code>domains/grpc/protocol/domain.proto</code>:</p>
<pre><code class="language-protobuf">service DomainPluginService {
    rpc Metadata(Empty) returns (MetadataResponse);
    rpc Initialize(InitializeRequest) returns (Empty);
    rpc Shutdown(Empty) returns (Empty);
    rpc Commands(Empty) returns (CommandsResponse);
    rpc ExecuteCommand(ExecuteCommandRequest) returns (ExecuteCommandResponse);
    rpc HandleHTTP(HTTPRequest) returns (HTTPResponse);
    rpc HandleWebSocket(stream WebSocketMessage) returns (stream WebSocketMessage);
    rpc Health(Empty) returns (HealthResponse);
}
</code></pre>
<h3>HTTP Proxying</h3>
<p>HTTP requests to <code>/api/&lt;plugin-name&gt;/*</code> are forwarded to the plugin via <code>HandleHTTP</code>:</p>
<ol>
<li>QNTX receives HTTP request</li>
<li>Request is serialized to <code>HTTPRequest</code> protobuf</li>
<li>Sent to plugin via gRPC</li>
<li>Plugin processes and returns <code>HTTPResponse</code></li>
<li>QNTX writes response to client</li>
</ol>
<h3>Command Execution</h3>
<p>CLI commands are executed via <code>ExecuteCommand</code>:</p>
<ol>
<li>User runs <code>qntx &lt;plugin&gt; &lt;subcommand&gt;</code></li>
<li>QNTX sends <code>ExecuteCommandRequest</code> with args/flags</li>
<li>Plugin executes command</li>
<li>Returns stdout/stderr/exit code</li>
</ol>
<h2>Building and Deploying</h2>
<h3>Building</h3>
<pre><code class="language-bash"># Build for current platform
go build -o qntx-myplugin .

# Cross-compile for Linux
GOOS=linux GOARCH=amd64 go build -o qntx-myplugin-linux .
</code></pre>
<h3>Installing</h3>
<p>Install to the QNTX plugins directory:</p>
<pre><code class="language-bash">mkdir -p ~/.qntx/plugins
cp qntx-myplugin ~/.qntx/plugins/
chmod +x ~/.qntx/plugins/qntx-myplugin
</code></pre>
<h3>Configuration</h3>
<p>Create plugin configuration at <code>~/.qntx/am.myplugin.toml</code>:</p>
<pre><code class="language-toml"># MyPlugin configuration
api_key = "${MYPLUGIN_API_KEY}"
endpoint = "https://api.example.com"
cache_ttl_seconds = 300
</code></pre>
<h2>Testing</h2>
<h3>Unit Tests</h3>
<pre><code class="language-go">func TestMyPlugin_Initialize(t *testing.T) {
    plugin := NewMyPlugin()

    // Create mock service registry
    logger := zaptest.NewLogger(t).Sugar()
    services := &amp;mockServiceRegistry{logger: logger}

    err := plugin.Initialize(context.Background(), services)
    assert.NoError(t, err)
}
</code></pre>
<h3>Integration Tests</h3>
<p>Use the provided test helpers:</p>
<pre><code class="language-go">func TestPluginIntegration(t *testing.T) {
    logger := zaptest.NewLogger(t).Sugar()
    plugin := NewMyPlugin()
    server := plugingrpc.NewPluginServer(plugin, logger)

    // Start server on random port
    listener, _ := net.Listen("tcp", "localhost:0")
    defer listener.Close()

    grpcServer := grpc.NewServer()
    protocol.RegisterDomainPluginServiceServer(grpcServer, server)
    go grpcServer.Serve(listener)
    defer grpcServer.Stop()

    // Connect client
    client, err := plugingrpc.NewPluginClient(listener.Addr().String(), logger)
    require.NoError(t, err)

    // Test plugin via client
    meta := client.Metadata()
    assert.Equal(t, "myplugin", meta.Name)
}
</code></pre>
<h2>Best Practices</h2>
<h3>Error Handling</h3>
<ul>
<li>Return descriptive errors from <code>Initialize</code> (causes QNTX to fail-fast)</li>
<li>Log errors before returning them</li>
<li>Use structured logging with context</li>
</ul>
<pre><code class="language-go">func (p *MyPlugin) Initialize(ctx context.Context, services domains.ServiceRegistry) error {
    logger := services.Logger("myplugin")

    if err := p.connectToAPI(); err != nil {
        logger.Errorw("Failed to connect to API", "error", err)
        return fmt.Errorf("API connection failed: %w", err)
    }

    return nil
}
</code></pre>
<h3>Health Checks</h3>
<p>Implement meaningful health checks:</p>
<pre><code class="language-go">func (p *MyPlugin) Health(ctx context.Context) domains.HealthStatus {
    details := make(map[string]interface{})

    // Check API connection
    if err := p.api.Ping(ctx); err != nil {
        return domains.HealthStatus{
            Healthy: false,
            Message: "API unreachable",
            Details: map[string]interface{}{
                "api_error": err.Error(),
            },
        }
    }
    details["api"] = "connected"

    return domains.HealthStatus{
        Healthy: true,
        Message: "All systems operational",
        Details: details,
    }
}
</code></pre>
<h3>HTTP Route Namespacing</h3>
<p>All routes must be under <code>/api/&lt;plugin-name&gt;/</code>:</p>
<pre><code class="language-go">func (p *MyPlugin) RegisterHTTP(mux *http.ServeMux) error {
    // ✅ Correct: namespaced routes
    mux.HandleFunc("/api/myplugin/", p.handleRoot)
    mux.HandleFunc("/api/myplugin/data", p.handleData)

    // ❌ Wrong: will conflict with other plugins
    // mux.HandleFunc("/data", p.handleData)

    return nil
}
</code></pre>
<h3>Graceful Shutdown</h3>
<p>Handle shutdown signals properly:</p>
<pre><code class="language-go">func (p *MyPlugin) Shutdown(ctx context.Context) error {
    logger := p.services.Logger("myplugin")

    // Stop background workers
    if p.worker != nil {
        p.worker.Stop()
    }

    // Close connections
    if p.apiClient != nil {
        if err := p.apiClient.Close(); err != nil {
            logger.Warnw("API client close error", "error", err)
        }
    }

    logger.Info("Plugin shutdown complete")
    return nil
}
</code></pre>
<h3>Version Compatibility</h3>
<p>Specify QNTX version constraints:</p>
<pre><code class="language-go">func (p *MyPlugin) Metadata() domains.Metadata {
    return domains.Metadata{
        Name:        "myplugin",
        Version:     "1.0.0",
        QNTXVersion: "&gt;= 0.1.0, &lt; 2.0.0", // Semver constraint
        // ...
    }
}
</code></pre>
<h2>Reference Implementation</h2>
<p>See the code domain plugin for a complete reference:</p>
<ul>
<li><strong>Source</strong>: <code>cmd/plugins/code/main.go</code></li>
<li><strong>Plugin</strong>: <code>domains/code/plugin.go</code></li>
<li><strong>Build</strong>: <code>make plugins</code></li>
</ul>
<h2>Related Documentation</h2>
<ul>
<li><a href="../architecture/ADR-001-domain-plugin-architecture.html">ADR-001: Domain Plugin Architecture</a></li>
<li><a href="../architecture/ADR-002-plugin-configuration.html">ADR-002: Plugin Configuration</a></li>
<li><a href="../architecture/ADR-003-plugin-communication.html">ADR-003: Plugin Communication</a></li>
<li><a href="./domain-plugin-api-reference.html">Domain Plugin API Reference</a></li>
<li><a href="./migrating-to-plugins.html">Migrating to Plugins</a></li>
</ul>
<footer class="site-footer">
  <p class="provenance">Generated by sitegen.nix at commit <a href="https://github.com/teranos/QNTX/commit/0e7ca38dd1dcce5d67e9797b91950b21353f137a-dirty">0e7ca38-dirty</a></p>
</footer>
</body>
</html>
