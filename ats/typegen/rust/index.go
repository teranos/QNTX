package rust

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// PackageExport represents a generated Rust module with its exported types
type PackageExport struct {
	PackageName string
	TypeNames   []string
}

// GenerateIndexFile creates a mod.rs file that re-exports all generated modules
func GenerateIndexFile(outputDir string, exports []PackageExport) error {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by ats/typegen from Go source. DO NOT EDIT.\n")
	sb.WriteString("// Regenerate with: make types\n\n")
	sb.WriteString("//! QNTX Type Definitions\n")
	sb.WriteString("//!\n")
	sb.WriteString("//! This module contains Rust type definitions generated from QNTX's Go source code.\n")
	sb.WriteString("//! All types include serde Serialize/Deserialize traits for JSON compatibility.\n")
	sb.WriteString("//!\n")
	sb.WriteString("//! ## Usage\n")
	sb.WriteString("//!\n")
	sb.WriteString("//! ```rust\n")
	sb.WriteString("//! use qntx_types::async::Job;\n")
	sb.WriteString("//! use qntx_types::sym::*;\n")
	sb.WriteString("//! ```\n\n")

	// Sort packages for deterministic output
	sort.Slice(exports, func(i, j int) bool {
		return exports[i].PackageName < exports[j].PackageName
	})

	// Declare all modules
	sb.WriteString("// Re-export all generated modules\n")
	for _, exp := range exports {
		modName := exp.PackageName
		// Handle Rust keywords
		if modName == "async" {
			sb.WriteString("pub mod r#async;\n")
		} else {
			sb.WriteString(fmt.Sprintf("pub mod %s;\n", modName))
		}
	}
	sb.WriteString("\n")

	// Re-export commonly used types for convenience
	sb.WriteString("// Re-export commonly used types for convenience\n")

	for _, exp := range exports {
		if len(exp.TypeNames) == 0 {
			continue
		}

		modName := exp.PackageName
		rustModRef := modName
		if modName == "async" {
			rustModRef = "r#async"
		}

		// Determine which types to re-export
		var typesToExport []string
		switch modName {
		case "async":
			typesToExport = []string{"ErrorCode", "ErrorContext", "Job", "JobStatus", "Progress", "PulseState"}
		case "budget":
			typesToExport = []string{"BudgetCalculation", "Limiter", "RateLimitConfig", "Tracker"}
		case "schedule":
			typesToExport = []string{"Execution", "ScheduledJob"}
		case "sym":
			// Re-export all sym constants with wildcard
			sb.WriteString(fmt.Sprintf("pub use %s::*; // All symbol constants\n", rustModRef))
			continue
		case "types":
			typesToExport = []string{"Attestation", "CodeBlock", "Event"}
		}

		if len(typesToExport) > 0 {
			// Filter to only types that actually exist
			var existingTypes []string
			for _, t := range typesToExport {
				for _, actualType := range exp.TypeNames {
					if t == actualType {
						existingTypes = append(existingTypes, t)
						break
					}
				}
			}

			if len(existingTypes) > 0 {
				sb.WriteString(fmt.Sprintf("pub use %s::{%s};\n",
					rustModRef, strings.Join(existingTypes, ", ")))
			}
		}
	}

	// Write the file
	indexPath := filepath.Join(outputDir, "mod.rs")
	if err := os.WriteFile(indexPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write mod.rs: %w", err)
	}

	return nil
}

// GenerateCargoToml creates a Cargo.toml for the qntx-types crate
func GenerateCargoToml(outputDir string) error {
	content := `[package]
name = "qntx-types"
version = "0.1.0"
edition = "2021"
description = "Generated Rust types from QNTX Go source"
publish = false

# NOTE: This file is generated by ats/typegen. Run 'make types' to regenerate.

[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
`

	cargoPath := filepath.Join(outputDir, "Cargo.toml")
	if err := os.WriteFile(cargoPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Cargo.toml: %w", err)
	}

	return nil
}

// GenerateLibRs creates a lib.rs file that re-exports all generated modules
// This is the crate entry point for use as a dependency
func GenerateLibRs(outputDir string, exports []PackageExport) error {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by ats/typegen from Go source. DO NOT EDIT.\n")
	sb.WriteString("// Regenerate with: make types\n\n")
	sb.WriteString("//! QNTX Type Definitions\n")
	sb.WriteString("//!\n")
	sb.WriteString("//! This crate contains Rust type definitions generated from QNTX's Go source code.\n")
	sb.WriteString("//! All types include serde Serialize/Deserialize traits for JSON compatibility.\n")
	sb.WriteString("//!\n")
	sb.WriteString("//! ## Usage\n")
	sb.WriteString("//!\n")
	sb.WriteString("//! ```rust\n")
	sb.WriteString("//! use qntx_types::async_types::Job;\n")
	sb.WriteString("//! use qntx_types::server::DaemonStatusMessage;\n")
	sb.WriteString("//! ```\n\n")

	// Sort packages for deterministic output
	sort.Slice(exports, func(i, j int) bool {
		return exports[i].PackageName < exports[j].PackageName
	})

	// Declare all modules with proper path attributes
	sb.WriteString("// Re-export all generated modules\n")
	sb.WriteString("// Note: 'async' is a reserved keyword in Rust, so we use 'async_types'\n")
	for _, exp := range exports {
		modName := exp.PackageName
		if modName == "async" {
			sb.WriteString("#[path = \"async.rs\"]\n")
			sb.WriteString("pub mod async_types;\n")
		} else {
			sb.WriteString(fmt.Sprintf("pub mod %s;\n", modName))
		}
	}
	sb.WriteString("\n")

	// Re-export commonly used types for convenience
	sb.WriteString("// Re-export commonly used types for convenience\n")

	for _, exp := range exports {
		if len(exp.TypeNames) == 0 {
			continue
		}

		modName := exp.PackageName
		rustModRef := modName
		if modName == "async" {
			rustModRef = "async_types"
		}

		// Determine which types to re-export
		var typesToExport []string
		switch modName {
		case "async":
			typesToExport = []string{"ErrorCode", "ErrorContext", "Job", "JobStatus", "Progress", "PulseState"}
		case "budget":
			typesToExport = []string{"Limiter", "Tracker"}
		case "schedule":
			typesToExport = []string{"Execution"}
		case "server":
			typesToExport = []string{"DaemonStatusMessage", "JobUpdateMessage", "StorageWarningMessage"}
		}

		if len(typesToExport) > 0 {
			// Filter to only types that actually exist
			var existingTypes []string
			for _, t := range typesToExport {
				for _, actualType := range exp.TypeNames {
					if t == actualType {
						existingTypes = append(existingTypes, t)
						break
					}
				}
			}

			if len(existingTypes) > 0 {
				sb.WriteString(fmt.Sprintf("pub use %s::{%s};\n",
					rustModRef, strings.Join(existingTypes, ", ")))
			}
		}
	}

	// Write the file
	libPath := filepath.Join(outputDir, "lib.rs")
	if err := os.WriteFile(libPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write lib.rs: %w", err)
	}

	return nil
}

// GenerateReadme creates a README.md file for the Rust types directory
func GenerateReadme(outputDir string, exports []PackageExport) error {
	var sb strings.Builder

	sb.WriteString("# QNTX Rust Types\n\n")
	sb.WriteString("Auto-generated Rust type definitions from QNTX's Go source code.\n\n")
	sb.WriteString("## Usage in Tauri\n\n")
	sb.WriteString("Add these dependencies to your `Cargo.toml`:\n\n")
	sb.WriteString("```toml\n")
	sb.WriteString("[dependencies]\n")
	sb.WriteString("serde = { version = \"1.0\", features = [\"derive\"] }\n")
	sb.WriteString("serde_json = \"1.0\"\n")
	sb.WriteString("lazy_static = \"1.4\"\n")
	sb.WriteString("```\n\n")
	sb.WriteString("Then in your Rust code:\n\n")
	sb.WriteString("```rust\n")
	sb.WriteString("use qntx_types::async::Job;\n")
	sb.WriteString("use qntx_types::sym::*;\n\n")
	sb.WriteString("// Use the types\n")
	sb.WriteString("let job_status = JobStatus::Running;\n\n")
	sb.WriteString("// Access symbol constants\n")
	sb.WriteString("println!(\"Pulse symbol: {}\", pulse);\n")
	sb.WriteString("println!(\"Command for IX: {}\", command_to_symbol.get(\"ix\").unwrap());\n")
	sb.WriteString("```\n\n")
	sb.WriteString("## Generated Files\n\n")
	sb.WriteString("- [`mod.rs`](./mod.rs) - Main module file with re-exports\n")

	// Sort exports for deterministic output
	sort.Slice(exports, func(i, j int) bool {
		return exports[i].PackageName < exports[j].PackageName
	})

	// Package descriptions
	descriptions := map[string]string{
		"async":    "Async job types (Job, JobStatus, Progress, etc.)",
		"budget":   "Rate limiting and budget types",
		"schedule": "Pulse scheduling types",
		"server":   "Server API request/response types",
		"sym":      "Symbol constants and mappings",
		"types":    "Core types (Attestation, Event, CodeBlock, etc.)",
	}

	for _, exp := range exports {
		desc := descriptions[exp.PackageName]
		if desc == "" {
			desc = fmt.Sprintf("%s types", exp.PackageName)
		}
		sb.WriteString(fmt.Sprintf("- [`%s.rs`](./%s.rs) - %s\n", exp.PackageName, exp.PackageName, desc))
	}

	sb.WriteString("\n## Type Compatibility\n\n")
	sb.WriteString("All types include `serde::Serialize` and `serde::Deserialize` traits, ensuring JSON compatibility with the QNTX Go server.\n\n")
	sb.WriteString("### Example: Deserializing from QNTX API\n\n")
	sb.WriteString("```rust\n")
	sb.WriteString("use qntx_types::async::Job;\n\n")
	sb.WriteString("let json = r#\"{\"id\":\"123\",\"handler_name\":\"test\",\"status\":\"completed\",...}\"#;\n")
	sb.WriteString("let job: Job = serde_json::from_str(json)?;\n")
	sb.WriteString("```\n\n")
	sb.WriteString("## Regeneration\n\n")
	sb.WriteString("Types are regenerated with:\n\n")
	sb.WriteString("```bash\n")
	sb.WriteString("make types\n")
	sb.WriteString("# or\n")
	sb.WriteString("./qntx typegen --lang rust --output types/generated/\n")
	sb.WriteString("```\n\n")
	sb.WriteString("**Do not manually edit** these files - they will be overwritten on the next generation.\n")

	// Write the file
	readmePath := filepath.Join(outputDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	return nil
}
