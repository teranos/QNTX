package markdown

import (
	"fmt"
	"go/ast"
	"sort"
	"strings"

	"github.com/teranos/QNTX/ats/typegen"
	"github.com/teranos/QNTX/ats/typegen/typescript"
)

// Generator implements typegen.Generator for Markdown documentation
type Generator struct {
	// TypeScript generator to show TS output alongside Go
	tsGen *typescript.Generator
}

// NewGenerator creates a new Markdown documentation generator
func NewGenerator() *Generator {
	return &Generator{
		tsGen: typescript.NewGenerator(),
	}
}

// Language returns "markdown"
func (g *Generator) Language() string {
	return "markdown"
}

// FileExtension returns "md"
func (g *Generator) FileExtension() string {
	return "md"
}

// GenerateInterface creates markdown documentation for a Go struct
func (g *Generator) GenerateInterface(name string, structType *ast.StructType) string {
	var sb strings.Builder

	// Generate TypeScript interface for comparison
	tsInterface := g.tsGen.GenerateInterface(name, structType)

	// Create side-by-side table with Go struct and TypeScript interface
	sb.WriteString(fmt.Sprintf("## %s\n\n", name))

	// Build Go struct source
	goSource := fmt.Sprintf("type %s struct {\n", name)
	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		for _, fieldName := range field.Names {
			// Skip unexported fields
			if !fieldName.IsExported() {
				continue
			}

			// Get field type as string
			fieldType := formatFieldType(field.Type)

			// Get struct tag if present
			tagStr := ""
			if field.Tag != nil {
				tagStr = " " + field.Tag.Value
			}

			goSource += fmt.Sprintf("\t%s %s%s\n", fieldName.Name, fieldType, tagStr)
		}
	}
	goSource += "}"

	// Create table
	sb.WriteString("<table>\n")
	sb.WriteString("<tr>\n")
	sb.WriteString("<th>Go Source</th>\n")
	sb.WriteString("<th>TypeScript</th>\n")
	sb.WriteString("</tr>\n")
	sb.WriteString("<tr>\n")
	sb.WriteString("<td>\n\n")
	sb.WriteString("```go\n")
	sb.WriteString(goSource)
	sb.WriteString("\n```\n\n")
	sb.WriteString("</td>\n")
	sb.WriteString("<td>\n\n")
	sb.WriteString("```typescript\n")
	sb.WriteString(tsInterface)
	sb.WriteString("\n```\n\n")
	sb.WriteString("</td>\n")
	sb.WriteString("</tr>\n")
	sb.WriteString("</table>\n")

	return sb.String()
}

// GenerateUnionType creates markdown documentation for a union type
func (g *Generator) GenerateUnionType(name string, values []string) string {
	var sb strings.Builder

	// Sort values for deterministic output
	sort.Strings(values)

	// Generate TypeScript union for comparison
	tsUnion := g.tsGen.GenerateUnionType(name, values)

	sb.WriteString(fmt.Sprintf("## %s\n\n", name))

	// Build Go type alias with const values
	goSource := fmt.Sprintf("type %s string\n\nconst (\n", name)
	for _, value := range values {
		// Convert value to const name (e.g., "queued" -> "Queued")
		// Handle single-character values safely
		constName := ""
		if len(value) > 0 {
			constName = strings.ToUpper(string(value[0]))
			if len(value) > 1 {
				constName += value[1:]
			}
		}
		goSource += fmt.Sprintf("\t%s%s %s = \"%s\"\n", name, constName, name, value)
	}
	goSource += ")"

	// Create table
	sb.WriteString("<table>\n")
	sb.WriteString("<tr>\n")
	sb.WriteString("<th>Go Source</th>\n")
	sb.WriteString("<th>TypeScript</th>\n")
	sb.WriteString("</tr>\n")
	sb.WriteString("<tr>\n")
	sb.WriteString("<td>\n\n")
	sb.WriteString("```go\n")
	sb.WriteString(goSource)
	sb.WriteString("\n```\n\n")
	sb.WriteString("</td>\n")
	sb.WriteString("<td>\n\n")
	sb.WriteString("```typescript\n")
	sb.WriteString(tsUnion)
	sb.WriteString("\n```\n\n")
	sb.WriteString("</td>\n")
	sb.WriteString("</tr>\n")
	sb.WriteString("</table>\n")

	return sb.String()
}

// GenerateFile creates a complete markdown documentation file
func (g *Generator) GenerateFile(result *typegen.Result) string {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# %s Types\n\n", result.PackageName))
	sb.WriteString("<!-- Code generated by ats/typegen from Go source. DO NOT EDIT. -->\n")
	sb.WriteString("<!-- Regenerate with: make types -->\n\n")

	sb.WriteString("This document shows Go type definitions alongside their TypeScript equivalents.\n")
	sb.WriteString("Use this as a reference when working with QNTX types in different contexts.\n\n")

	// Sort type names for deterministic output
	names := make([]string, 0, len(result.Types))
	for name := range result.Types {
		names = append(names, name)
	}
	sort.Strings(names)

	// Add each type with source links
	for i, name := range names {
		typeMarkdown := result.Types[name]

		// Inject source link after the heading if we have position info
		if pos, ok := result.TypePositions[name]; ok {
			// Find the heading line (## TypeName)
			lines := strings.Split(typeMarkdown, "\n")
			if len(lines) > 0 && strings.HasPrefix(lines[0], "## ") {
				// Insert source link after heading
				sourceLink := fmt.Sprintf("\n**Source**: [`%s:%d`](https://github.com/teranos/QNTX/blob/main/%s#L%d)\n",
					pos.File, pos.Line, pos.File, pos.Line)
				lines = append(lines[:1], append([]string{sourceLink}, lines[1:]...)...)
				typeMarkdown = strings.Join(lines, "\n")
			}
		}

		sb.WriteString(typeMarkdown)
		if i < len(names)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// formatFieldType converts an AST type expression to a string
func formatFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		// Qualified type like time.Time
		if ident, ok := t.X.(*ast.Ident); ok {
			return ident.Name + "." + t.Sel.Name
		}
		return t.Sel.Name
	case *ast.StarExpr:
		// Pointer type
		return "*" + formatFieldType(t.X)
	case *ast.ArrayType:
		// Slice or array
		return "[]" + formatFieldType(t.Elt)
	case *ast.MapType:
		// Map type
		return fmt.Sprintf("map[%s]%s", formatFieldType(t.Key), formatFieldType(t.Value))
	case *ast.InterfaceType:
		return "interface{}"
	default:
		return "unknown"
	}
}
