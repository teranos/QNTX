#!/usr/bin/env bash
# QNTX pre-commit hook - Go formatting and binary prevention
#
# This hook:
# 1. BLOCKS any binary files from being committed
# 2. Runs gofmt on all staged Go files to ensure consistent formatting
#
# Unlike the Nix-based pre-commit hooks, this runs locally and has network access
# for downloading Go modules if needed.

set -e

# ============================================================================
# BINARY DETECTION - BLOCKS COMMITS WITH BINARIES
# ============================================================================

echo "Checking for binary files..."

# Get all staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -n "$STAGED_FILES" ]; then
  BINARY_FILES=""

  for FILE in $STAGED_FILES; do
    # Skip files that don't exist (deletions)
    if [ ! -f "$FILE" ]; then
      continue
    fi

    # Use file command to detect binaries
    # Binaries will contain "executable" or be identified as data/compiled
    FILE_TYPE=$(file -b "$FILE")

    # Check for common binary indicators
    if echo "$FILE_TYPE" | grep -qE "(executable|Mach-O|ELF|compiled|PE32|binary data)"; then
      # Exclude shell scripts which are also "executable"
      if ! echo "$FILE_TYPE" | grep -q "script"; then
        BINARY_FILES="$BINARY_FILES\n  - $FILE ($FILE_TYPE)"
      fi
    fi

    # Also check file extension for known binary types
    if echo "$FILE" | grep -qE '\.(so|dylib|a|o|exe|dll|bin|out)$'; then
      BINARY_FILES="$BINARY_FILES\n  - $FILE (binary extension)"
    fi
  done

  if [ -n "$BINARY_FILES" ]; then
    echo ""
    echo "❌ ERROR: Binary files detected in commit!"
    echo ""
    echo "The following binary files cannot be committed:$BINARY_FILES"
    echo ""
    echo "Binaries bloat the git repository and should NEVER be committed."
    echo "Add these files to .gitignore instead."
    echo ""
    echo "To bypass this check (NOT RECOMMENDED):"
    echo "  git commit --no-verify"
    echo ""
    exit 1
  fi
fi

echo "✓ No binary files detected"

# ============================================================================
# GO FORMATTING
# ============================================================================

# Get list of staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

if [ -z "$STAGED_GO_FILES" ]; then
  exit 0
fi

# Check if gofmt is available
if ! command -v gofmt &> /dev/null; then
  echo "Error: gofmt not found. Please install Go toolchain."
  exit 1
fi

# Run gofmt on staged files
echo "Running gofmt on staged Go files..."
UNFORMATTED_FILES=""

for FILE in $STAGED_GO_FILES; do
  # Check if file needs formatting
  if ! gofmt -l "$FILE" | grep -q .; then
    continue
  fi

  # Format the file
  gofmt -w "$FILE"

  # Re-stage the formatted file
  git add "$FILE"

  UNFORMATTED_FILES="$UNFORMATTED_FILES\n  - $FILE"
done

if [ -n "$UNFORMATTED_FILES" ]; then
  echo -e "Formatted and re-staged Go files:$UNFORMATTED_FILES"
fi

echo "✓ Go formatting check passed"

# ============================================================================
# RUST FORMATTING
# ============================================================================

# Get list of staged Rust files
STAGED_RUST_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.rs$' || true)

if [ -n "$STAGED_RUST_FILES" ]; then
  echo "Running cargo fmt check on staged Rust files..."

  # Check if cargo is available
  if ! command -v cargo &> /dev/null; then
    echo "Error: cargo not found. Please install Rust toolchain."
    exit 1
  fi

  # Run cargo fmt check for each crate with changes
  CRATES_TO_CHECK=""
  for FILE in $STAGED_RUST_FILES; do
    # Find which crate this file belongs to
    CRATE_DIR=$(dirname "$FILE")
    while [ "$CRATE_DIR" != "." ] && [ "$CRATE_DIR" != "/" ]; do
      if [ -f "$CRATE_DIR/Cargo.toml" ]; then
        CRATES_TO_CHECK="$CRATES_TO_CHECK $CRATE_DIR"
        break
      fi
      CRATE_DIR=$(dirname "$CRATE_DIR")
    done
  done

  # Remove duplicates
  CRATES_TO_CHECK=$(echo "$CRATES_TO_CHECK" | tr ' ' '\n' | sort -u | tr '\n' ' ')

  # Check formatting for each crate
  for CRATE in $CRATES_TO_CHECK; do
    echo "Checking Rust formatting in $CRATE..."
    if ! (cd "$CRATE" && cargo fmt --check 2>/dev/null); then
      echo ""
      echo "❌ ERROR: Rust formatting issues detected!"
      echo ""
      echo "Run 'cargo fmt' to fix formatting issues."
      echo "You can run it from the project root or in specific crates:"
      echo "  cd $CRATE && cargo fmt"
      echo ""
      exit 1
    fi
  done

  echo "✓ Rust formatting check passed"
fi

# ============================================================================
# TYPESCRIPT TYPE CHECKING - TypeScript files only
# ============================================================================

# Check if any TypeScript files are staged
TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx)$' || true)

if [ -n "$TS_FILES" ]; then
  echo "TypeScript files changed, running type check..."

  # Check if bun is available
  if ! command -v bun &> /dev/null; then
    echo "Warning: bun not found, skipping TypeScript type check"
  else
    # Run typecheck from web directory
    if [ -d "web" ] && [ -f "web/package.json" ]; then
      cd web
      if bun run typecheck; then
        echo "✓ TypeScript type check passed"
      else
        echo "✗ TypeScript type check failed"
        echo "Fix type errors before committing, or run: cd web && bun run typecheck"
        exit 1
      fi
      cd ..
    fi
  fi
fi

exit 0
