// Code generated by ats/typegen from Go source. DO NOT EDIT.
// Regenerate with: make types
// Source package: sym
// Source last modified: 2025-12-26T21:36:27+01:00
// Source version: 63a2daf

//! # sym module
//!
//! Generated from Go package: sym
//!
//! This module contains auto-generated type definitions.
//! All types include serde Serialize/Deserialize traits for JSON compatibility.

#![allow(clippy::all)]
#![allow(unused_imports)]

pub const AM: &str = "≡";
pub const r#AS: &str = "+";
pub const AT: &str = "✦";
pub const AX: &str = "⋈";
pub const BY: &str = "⌬";
pub const DB: &str = "⊔";
pub const I: &str = "⍟";
pub const IS: &str = "=";
pub const IX: &str = "⨳";
pub const OF: &str = "∈";
pub const PULSE: &str = "꩜";
pub const PULSE_CLOSE: &str = "❀";
pub const PULSE_OPEN: &str = "✿";
pub const SO: &str = "⟶";


pub const PALETTE_ORDER: &[&str] = &[I, AM, IX, AX, r#AS, IS, OF, BY, AT, SO];

lazy_static::lazy_static! {
    pub static ref COMMAND_DESCRIPTIONS: std::collections::HashMap<&'static str, &'static str> = {
        let mut m = std::collections::HashMap::new();
        m.insert("am", "Structure — QNTX's internal understanding");
        m.insert("as", "Assert — Emit an attestation");
        m.insert("at", "Event — Temporal marker/moment");
        m.insert("ax", "Expand — Surface related context");
        m.insert("by", "Actor — Catalyst/origin of action");
        m.insert("i", "Self — Your vantage point into QNTX");
        m.insert("is", "Identity — Subject/equivalence");
        m.insert("ix", "Ingest — Import external data");
        m.insert("of", "Membership — Element-of/belonging");
        m.insert("so", "Therefore — Consequent action");
        m
    };
}
lazy_static::lazy_static! {
    pub static ref COMMAND_TO_SYMBOL: std::collections::HashMap<&'static str, &'static str> = {
        let mut m = std::collections::HashMap::new();
        m.insert("am", AM);
        m.insert("as", r#AS);
        m.insert("at", AT);
        m.insert("ax", AX);
        m.insert("by", BY);
        m.insert("i", I);
        m.insert("is", IS);
        m.insert("ix", IX);
        m.insert("of", OF);
        m.insert("so", SO);
        m
    };
}
lazy_static::lazy_static! {
    pub static ref SYMBOL_TO_COMMAND: std::collections::HashMap<&'static str, &'static str> = {
        let mut m = std::collections::HashMap::new();
        m.insert(AM, "am");
        m.insert(r#AS, "as");
        m.insert(AT, "at");
        m.insert(AX, "ax");
        m.insert(BY, "by");
        m.insert(I, "i");
        m.insert(IS, "is");
        m.insert(IX, "ix");
        m.insert(OF, "of");
        m.insert(SO, "so");
        m
    };
}

