// Code generated by ats/typegen from Go source. DO NOT EDIT.
// Regenerate with: make types
// Source package: sym

pub const am: &str = "≡";
pub const r#as: &str = "+";
pub const at: &str = "✦";
pub const ax: &str = "⋈";
pub const by: &str = "⌬";
pub const db: &str = "⊔";
pub const i: &str = "⍟";
pub const is: &str = "=";
pub const ix: &str = "⨳";
pub const of: &str = "∈";
pub const pulse: &str = "꩜";
pub const pulse_close: &str = "❀";
pub const pulse_open: &str = "✿";
pub const so: &str = "⟶";


pub const palette_order: &[&str] = &[i, am, ix, ax, r#as, is, of, by, at, so];

lazy_static::lazy_static! {
    pub static ref command_descriptions: std::collections::HashMap<&'static str, &'static str> = {
        let mut m = std::collections::HashMap::new();
        m.insert("am", "Structure — QNTX's internal understanding");
        m.insert("as", "Assert — Emit an attestation");
        m.insert("at", "Event — Temporal marker/moment");
        m.insert("ax", "Expand — Surface related context");
        m.insert("by", "Actor — Catalyst/origin of action");
        m.insert("i", "Self — Your vantage point into QNTX");
        m.insert("is", "Identity — Subject/equivalence");
        m.insert("ix", "Ingest — Import external data");
        m.insert("of", "Membership — Element-of/belonging");
        m.insert("so", "Therefore — Consequent action");
        m
    };
}
lazy_static::lazy_static! {
    pub static ref command_to_symbol: std::collections::HashMap<&'static str, &'static str> = {
        let mut m = std::collections::HashMap::new();
        m.insert("am", am);
        m.insert("as", r#as);
        m.insert("at", at);
        m.insert("ax", ax);
        m.insert("by", by);
        m.insert("i", i);
        m.insert("is", is);
        m.insert("ix", ix);
        m.insert("of", of);
        m.insert("so", so);
        m
    };
}
lazy_static::lazy_static! {
    pub static ref symbol_to_command: std::collections::HashMap<&'static str, &'static str> = {
        let mut m = std::collections::HashMap::new();
        m.insert(am, "am");
        m.insert(r#as, "as");
        m.insert(at, "at");
        m.insert(ax, "ax");
        m.insert(by, "by");
        m.insert(i, "i");
        m.insert(is, "is");
        m.insert(ix, "ix");
        m.insert(of, "of");
        m.insert(so, "so");
        m
    };
}

