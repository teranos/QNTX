syntax = "proto3";

package protocol;

option go_package = "github.com/teranos/QNTX/plugin/grpc/protocol";

// DomainPluginService is the gRPC service for external domain plugins
service DomainPluginService {
  // Metadata returns plugin metadata
  rpc Metadata(Empty) returns (MetadataResponse);

  // Initialize initializes the plugin
  rpc Initialize(InitializeRequest) returns (InitializeResponse);

  // Shutdown shuts down the plugin
  rpc Shutdown(Empty) returns (Empty);

  // HandleHTTP handles an HTTP request
  rpc HandleHTTP(HTTPRequest) returns (HTTPResponse);

  // HandleWebSocket handles a WebSocket connection (bidirectional streaming)
  rpc HandleWebSocket(stream WebSocketMessage) returns (stream WebSocketMessage);

  // Health checks plugin health
  rpc Health(Empty) returns (HealthResponse);

  // ConfigSchema returns the configuration schema for this plugin
  rpc ConfigSchema(Empty) returns (ConfigSchemaResponse);

  // ExecuteJob executes an async job
  // Used by Pulse to route jobs to plugin-registered handlers
  rpc ExecuteJob(ExecuteJobRequest) returns (ExecuteJobResponse);
}

message Empty {}

message MetadataResponse {
  string name = 1;
  string version = 2;
  string qntx_version = 3;
  string description = 4;
  string author = 5;
  string license = 6;
}

message InitializeRequest {
  // Service endpoints the plugin can call back to QNTX core
  // Format: "host:port" for TCP (e.g., "localhost:50051")
  //
  // Note: Database access is not provided - database is a hard boundary.
  // Plugins should use attestations via ats_store_endpoint instead.

  // ats_store_endpoint: gRPC endpoint for ATSStoreService
  // Provides: Attestation creation, querying, and management
  string ats_store_endpoint = 1;

  // queue_endpoint: gRPC endpoint for QueueService
  // Provides: Async job enqueue, status, and management
  string queue_endpoint = 2;

  // auth_token: Simple token for authenticating with service endpoints
  // Plugins must include this token in all service RPC calls
  string auth_token = 3;

  // Plugin-specific configuration values
  // Simple types (string, int, bool) passed as string representations
  // Complex types (maps, slices) JSON-encoded as strings
  // Plugins should parse and validate values appropriate to their schema
  map<string, string> config = 4;
}

message HTTPRequest {
  string method = 1;
  string path = 2;
  repeated HTTPHeader headers = 3;
  bytes body = 4;
}

message HTTPResponse {
  int32 status_code = 1;
  repeated HTTPHeader headers = 2;
  bytes body = 3;
}

// HTTPHeader represents an HTTP header with support for multiple values.
// HTTP headers can have multiple values (e.g., Set-Cookie, Accept).
message HTTPHeader {
  string name = 1;
  repeated string values = 2;
}

message WebSocketMessage {
  enum Type {
    CONNECT = 0;
    DATA = 1;
    CLOSE = 2;
    PING = 3;   // Client/Server can send for keepalive
    PONG = 4;   // Response to PING
    ERROR = 5;  // Error notification
  }

  Type type = 1;
  bytes data = 2;
  map<string, string> headers = 3;  // Optional headers/metadata
  int64 timestamp = 4;              // For latency measurement (Unix timestamp in nanoseconds)
}

message HealthResponse {
  bool healthy = 1;
  string message = 2;
  map<string, string> details = 3;
}

message ConfigSchemaResponse {
  // Map of config field name to schema definition
  map<string, ConfigFieldSchema> fields = 1;
}

message ConfigFieldSchema {
  // Field type: "string", "number", "boolean", "array"
  string type = 1;

  // Human-readable description of what this field does
  string description = 2;

  // Default value (as string representation)
  string default_value = 3;

  // Whether this field is required
  bool required = 4;

  // For number types: minimum value (optional)
  string min_value = 5;

  // For number types: maximum value (optional)
  string max_value = 6;

  // For string types: validation pattern (regex, optional)
  string pattern = 7;

  // For array types: element type (optional)
  string element_type = 8;
}

// InitializeResponse is returned by Initialize RPC
message InitializeResponse {
  // Handler names this plugin can execute
  // Examples: ["python.script", "python.webhook", "ixgest.git"]
  // Empty list means plugin provides no async handlers (backward compatible)
  repeated string handler_names = 1;
}

// ExecuteJobRequest is sent to plugins to execute an async job
message ExecuteJobRequest {
  string job_id = 1;           // For logging/tracking
  string handler_name = 2;     // Which handler to invoke
  bytes payload = 3;           // Job-specific data (JSON)
  int64 timeout_secs = 4;      // Execution timeout (0 = no timeout)
}

// ExecuteJobResponse is returned after job execution
message ExecuteJobResponse {
  bool success = 1;
  string error = 2;            // Error message if failed
  bytes result = 3;            // Optional result data (JSON)

  // Progress tracking (optional) - Pulse updates job.Progress
  int32 progress_current = 4;
  int32 progress_total = 5;

  // Cost tracking (optional) - Pulse updates job.CostActual
  double cost_actual = 6;
}
