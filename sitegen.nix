{ pkgs
, gitRevision ? "unknown"
, gitShortRev ? "unknown"
, gitTag ? null
, buildDate ? null
, ciUser ? null
, ciPipeline ? null
, ciRunId ? null
  # Nix infrastructure metadata (passed from flake)
, nixPackages ? []
, nixApps ? []
, nixContainers ? []
}:

let
  inherit (pkgs) lib;

  # GitHub repo for links
  githubRepo = "teranos/QNTX";

  # Provenance info
  provenance = {
    commit = gitShortRev;
    fullCommit = gitRevision;
    tag = gitTag;
    generator = "sitegen.nix";
    date = buildDate;
    user = ciUser;
    pipeline = ciPipeline;
    runId = ciRunId;
  };

  # Static assets
  cssFiles = {
    core = ./web/css/core.css;
    utilities = ./web/css/utilities.css;
    docs = ./web/css/docs.css;
  };
  jsFiles = {
    search = ./web/js/search.js;
    releases = ./web/js/releases.js;
  };
  logo = ./web/qntx.jpg;

  # Use Nix's filesystem library to discover markdown files
  docsDir = ./docs;
  allFiles = lib.filesystem.listFilesRecursive docsDir;
  markdownFiles =
    let filtered = lib.filter (path: lib.hasSuffix ".md" (toString path)) allFiles;
    in if filtered == [ ]
    then throw "No markdown files found in docs/ directory"
    else filtered;

  # Calculate relative path from docs/ directory
  getRelativePath = path:
    lib.removePrefix "${toString docsDir}/" (toString path);

  # SEG symbol mappings for semantic navigation
  # Based on docs/development/design-philosophy.md
  categoryMeta = {
    "getting-started" = { symbol = "‚çü"; desc = "Entry points"; };
    "architecture" = { symbol = "‚å¨"; desc = "System design"; };
    "development" = { symbol = "‚®≥"; desc = "Workflows"; };
    "types" = { symbol = "‚â°"; desc = "Type reference"; };
    "api" = { symbol = "‚ãà"; desc = "API reference"; };
    "testing" = { symbol = "‚ú¶"; desc = "Test guides"; };
    "security" = { symbol = "+"; desc = "Security"; };
    "vision" = { symbol = "‚ü∂"; desc = "Future direction"; };
    "_root" = { symbol = ""; desc = ""; };
  };

  # Get category metadata with fallback
  getCategoryMeta = cat:
    categoryMeta.${cat} or { symbol = ""; desc = ""; };

  # Create structured file info for each markdown file
  mkFileInfo = mdPath:
    let
      relPath = getRelativePath mdPath;
      dir = dirOf relPath;
      name = lib.removeSuffix ".md" (baseNameOf relPath);
      htmlPath = lib.removeSuffix ".md" relPath + ".html";
      depth = lib.length (lib.filter (x: x != "") (lib.splitString "/" (if dir == "." then "" else dir)));
      prefix = if depth == 0 then "." else lib.concatStringsSep "/" (lib.genList (_: "..") depth);
    in
    {
      inherit mdPath relPath dir name htmlPath depth prefix;
    };

  # Process all files to get structured info
  fileInfos = map mkFileInfo markdownFiles;

  # Group files by directory for index generation
  groupedFiles = lib.groupBy (f: if f.dir == "." then "_root" else (lib.head (lib.splitString "/" f.dir))) fileInfos;

  # HTML escaping function to prevent XSS from malicious filenames
  escapeHtml = s: builtins.replaceStrings
    [ "<" ">" "&" "\"" "'" ]
    [ "&lt;" "&gt;" "&amp;" "&quot;" "&#39;" ]
    s;

  # Convert kebab-case to Title Case
  toTitleCase = s:
    let
      words = lib.splitString "-" s;
      capitalize = w: lib.toUpper (lib.substring 0 1 w) + lib.substring 1 (lib.stringLength w) w;
    in
    lib.concatStringsSep " " (map capitalize words);

  # HTML template - head section
  htmlHead = title: prefix: ''
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${escapeHtml title}</title>
        <link rel="icon" type="image/jpeg" href="${prefix}/qntx.jpg">
        <link rel="stylesheet" href="${prefix}/css/core.css">
        <link rel="stylesheet" href="${prefix}/css/docs.css">
    </head>
  '';

  # Provenance footer HTML
  # Build provenance line with available info
  commitLink = ''<a href="https://github.com/${githubRepo}/commit/${provenance.fullCommit}">${provenance.commit}</a>'';
  tagInfo = if provenance.tag != null then " (${provenance.tag})" else "";
  dateInfo = if provenance.date != null then " on ${provenance.date}" else "";
  userInfo = if provenance.user != null then " by ${provenance.user}" else "";
  pipelineInfo =
    if provenance.pipeline != null && provenance.runId != null
    then '' via <a href="https://github.com/${githubRepo}/actions/runs/${provenance.runId}">${provenance.pipeline}</a>''
    else if provenance.pipeline != null
    then " via ${provenance.pipeline}"
    else "";

  provenanceFooter = ''
        <footer class="site-footer">
            <p class="provenance">Generated by ${provenance.generator} at commit ${commitLink}${tagInfo}${dateInfo}${userInfo}${pipelineInfo}</p>
        </footer>
  '';

  # Document page structure
  docBody = prefix: ''
    <body>
        <nav class="doc-nav"><a href="${prefix}/index.html"><img src="${prefix}/qntx.jpg" alt="QNTX" class="site-logo">Documentation Home</a></nav>
  '';

  # Index page structure
  indexBody = ''
    <body>
        <div class="doc-header">
            <img src="./qntx.jpg" alt="QNTX Logo">
            <h1>QNTX Documentation</h1>
        </div>
        <div class="search-container">
            <input type="search" id="search-input" class="search-input" placeholder="Search documentation..." aria-label="Search documentation">
            <div id="search-results" class="search-results" hidden></div>
        </div>

        <nav class="quick-links">
            <a href="./downloads.html" class="quick-link">Downloads</a>
            <a href="./infrastructure.html" class="quick-link">Build Infrastructure</a>
        </nav>

        <section class="download-section quick-download">
            <h2>Quick Download</h2>
            <div id="latest-release">
                <p class="loading">Loading latest release...</p>
            </div>
            <p style="margin-top: 12px;"><a href="./downloads.html">View all downloads and installation options</a></p>
        </section>
  '';

  # Category order for consistent display
  categoryOrder = [ "getting-started" "architecture" "development" "types" "api" "security" "testing" "vision" ];

  # Generate index section with SEG symbol
  genIndexSection = category: files:
    let
      sortedFiles = lib.sort (a: b: a.name < b.name) files;
      meta = getCategoryMeta category;
      categoryTitle = toTitleCase category;
      symbolHtml = if meta.symbol != "" then ''<span class="category-symbol">${meta.symbol}</span>'' else "";
      descHtml = if meta.desc != "" then ''<span class="category-desc">${escapeHtml meta.desc}</span>'' else "";
      fileLinks = map (f: ''            <li><a href="${f.htmlPath}"><span class="doc-name">${escapeHtml (toTitleCase f.name)}</span></a></li>'') sortedFiles;
    in
    ''
        <section class="category-section">
            <div class="category-header">
                ${symbolHtml}<h2 class="category-title">${escapeHtml categoryTitle}</h2>${descHtml}
            </div>
            <ul class="doc-list">
    ${lib.concatStringsSep "\n" fileLinks}
            </ul>
        </section>'';

  # Generate full index content
  indexContent =
    let
      rootFiles = groupedFiles._root or [ ];
      # Sort categories by defined order, then alphabetically for any extras
      sortedCategories =
        let
          orderedCats = lib.filter (c: lib.hasAttr c groupedFiles) categoryOrder;
          extraCats = lib.filter (c: c != "_root" && !(lib.elem c categoryOrder)) (lib.attrNames groupedFiles);
        in
        orderedCats ++ (lib.sort (a: b: a < b) extraCats);
      rootSection = if rootFiles != [ ] then genIndexSection "_root" rootFiles else "";
      categorySections = map (cat: genIndexSection cat groupedFiles.${cat}) sortedCategories;
    in
    htmlHead "QNTX Documentation" "." +
    indexBody +
    rootSection +
    lib.concatStringsSep "\n" categorySections +
    provenanceFooter +
    ''
        <script src="./js/search.js"></script>
        <script src="./js/releases.js"></script>
    </body>
    </html>'';

  # Create a separate derivation for each markdown file (enables incremental rebuilds)
  mkHtmlDerivation = fileInfo:
    let
      # Read markdown content and rewrite .md links to .html (pure Nix)
      mdContent = builtins.readFile fileInfo.mdPath;
      rewrittenMd = builtins.replaceStrings [ ".md)" ] [ ".html)" ] mdContent;
    in
    pkgs.runCommand "qntx-doc-${fileInfo.name}"
      {
        nativeBuildInputs = [ pkgs.pulldown-cmark ];
      }
      ''
        mkdir -p "$out/$(dirname "${fileInfo.htmlPath}")"
        {
          cat <<'EOF'
${htmlHead "QNTX - ${fileInfo.name}" fileInfo.prefix}
${docBody fileInfo.prefix}
EOF
          cat <<'EOF' | ${pkgs.pulldown-cmark}/bin/pulldown-cmark -T -S -F
${rewrittenMd}
EOF
          cat <<'EOF'
${provenanceFooter}
EOF
          echo "    </body>"
          echo "</html>"
        } > "$out/${fileInfo.htmlPath}"
      '';

  # Generate all HTML file derivations
  htmlDerivations = map mkHtmlDerivation fileInfos;

  # Generate search index JSON
  # Escape for JSON string values
  escapeJson = s: builtins.replaceStrings
    [ "\\" "\"" "\n" "\r" "\t" ]
    [ "\\\\" "\\\"" "\\n" "\\r" "\\t" ]
    s;

  # Strip markdown syntax for plain text content
  stripMarkdown = s:
    let
      # Remove code blocks
      noCodeBlocks = builtins.replaceStrings [ "```" ] [ "" ] s;
      # Remove headers markers
      noHeaders = builtins.replaceStrings [ "# " "## " "### " "#### " ] [ "" "" "" "" ] noCodeBlocks;
      # Remove emphasis markers
      noEmphasis = builtins.replaceStrings [ "**" "__" "*" "_" "`" ] [ "" "" "" "" "" ] noHeaders;
      # Remove link syntax [text](url) -> text (simplified)
      noLinks = builtins.replaceStrings [ "[" "](" ] [ "" " " ] noEmphasis;
    in
    noLinks;

  # Generate search index entry for a file
  mkSearchEntry = fileInfo:
    let
      mdContent = builtins.readFile fileInfo.mdPath;
      # Get first 500 chars of stripped content for search
      strippedContent = stripMarkdown mdContent;
      truncatedContent = lib.substring 0 500 strippedContent;
      category = if fileInfo.dir == "." then "General" else toTitleCase (lib.head (lib.splitString "/" fileInfo.dir));
    in
    ''{"title":"${escapeJson (toTitleCase fileInfo.name)}","path":"${fileInfo.htmlPath}","category":"${escapeJson category}","content":"${escapeJson truncatedContent}"}'';

  searchIndexContent = "[" + lib.concatStringsSep "," (map mkSearchEntry fileInfos) + "]";

  searchIndexFile = pkgs.writeTextFile {
    name = "qntx-docs-search-index";
    text = searchIndexContent;
    destination = "/search-index.json";
  };

  # Static assets using linkFarm (pure Nix)
  staticAssets = pkgs.linkFarm "qntx-docs-static" [
    { name = "css/core.css"; path = cssFiles.core; }
    { name = "css/utilities.css"; path = cssFiles.utilities; }
    { name = "css/docs.css"; path = cssFiles.docs; }
    { name = "js/search.js"; path = jsFiles.search; }
    { name = "js/releases.js"; path = jsFiles.releases; }
    { name = "qntx.jpg"; path = logo; }
  ];

  # Index file as a derivation
  indexFile = pkgs.writeTextFile {
    name = "qntx-docs-index";
    text = indexContent;
    destination = "/index.html";
  };

  # GitHub release base URL
  githubReleasesUrl = "https://github.com/${githubRepo}/releases";

  # Downloads page content
  downloadsContent =
    htmlHead "QNTX Downloads" "." +
    ''
    <body>
        <nav class="doc-nav"><a href="./index.html"><img src="./qntx.jpg" alt="QNTX" class="site-logo">Documentation Home</a></nav>

        <h1>Download QNTX</h1>

        <section class="download-section">
            <h2>Recommended: Install via Nix</h2>
            <p>The easiest way to install QNTX is using the Nix package manager:</p>
            <div class="install-code">nix profile install github:${githubRepo}</div>
            <p>This installs the latest version and handles all dependencies automatically.</p>
        </section>

        <section class="download-section">
            <h2>Release Downloads</h2>
            <div id="release-downloads">
                <p class="loading">Loading releases...</p>
            </div>
        </section>

        <section class="download-section">
            <h2>Docker Images</h2>
            <div class="download-cards">
                <div class="download-card">
                    <div class="download-card-header">
                        <span class="download-card-icon">üì¶</span>
                        <span class="download-card-title">QNTX Core</span>
                    </div>
                    <p class="download-card-desc">Main QNTX container image with all core functionality.</p>
                    <a href="https://github.com/${githubRepo}/pkgs/container/qntx" class="download-btn">View Image</a>
                </div>

                <div class="download-card">
                    <div class="download-card-header">
                        <span class="download-card-icon">üì¶</span>
                        <span class="download-card-title">qntx-code Plugin</span>
                    </div>
                    <p class="download-card-desc">Code analysis and Git integration plugin.</p>
                    <a href="https://github.com/${githubRepo}/pkgs/container/qntx-code-plugin" class="download-btn">View Image</a>
                </div>

                <div class="download-card">
                    <div class="download-card-header">
                        <span class="download-card-icon">üì¶</span>
                        <span class="download-card-title">qntx-python Plugin</span>
                    </div>
                    <p class="download-card-desc">Python runtime plugin with PyO3 integration.</p>
                    <a href="https://github.com/${githubRepo}/pkgs/container/qntx-python-plugin" class="download-btn">View Image</a>
                </div>
            </div>
        </section>

        <section class="download-section">
            <h2>Build from Source</h2>
            <p>Clone the repository and build with Go 1.24+:</p>
            <div class="install-code">git clone https://github.com/${githubRepo}.git
cd QNTX
make build</div>
            <p>Or use Nix for reproducible builds:</p>
            <div class="install-code">nix build github:${githubRepo}</div>
        </section>

${provenanceFooter}
        <script src="./js/releases.js"></script>
    </body>
    </html>'';

  downloadsFile = pkgs.writeTextFile {
    name = "qntx-docs-downloads";
    text = downloadsContent;
    destination = "/downloads.html";
  };

  # Build info JSON for programmatic access
  # Filter out null values for cleaner JSON
  buildInfoContent = builtins.toJSON (lib.filterAttrs (_: v: v != null) {
    generator = provenance.generator;
    commit = provenance.fullCommit;
    shortCommit = provenance.commit;
    tag = provenance.tag;
    date = provenance.date;
    user = provenance.user;
    pipeline = provenance.pipeline;
    runId = provenance.runId;
    repository = "https://github.com/${githubRepo}";
  });

  buildInfoFile = pkgs.writeTextFile {
    name = "qntx-docs-build-info";
    text = buildInfoContent;
    destination = "/build-info.json";
  };

  # Infrastructure documentation page
  # Generate package list HTML
  renderPackage = pkg: ''
            <tr>
                <td><code>${escapeHtml pkg.name}</code></td>
                <td>${escapeHtml pkg.description}</td>
                <td><code>nix build .#${escapeHtml pkg.name}</code></td>
            </tr>'';

  renderApp = app: ''
            <tr>
                <td><code>${escapeHtml app.name}</code></td>
                <td>${escapeHtml app.description}</td>
                <td><code>nix run .#${escapeHtml app.name}</code></td>
            </tr>'';

  renderContainer = ctr: ''
            <div class="download-card">
                <div class="download-card-header">
                    <span class="download-card-icon">üì¶</span>
                    <span class="download-card-title">${escapeHtml ctr.name}</span>
                </div>
                <p class="download-card-desc">${escapeHtml ctr.description}</p>
                <div class="container-details">
                    <p><strong>Image:</strong> <code>${escapeHtml ctr.image}</code></p>
                    <p><strong>Architectures:</strong> ${escapeHtml (lib.concatStringsSep ", " ctr.architectures)}</p>
                    ${if ctr.ports != [] then ''<p><strong>Ports:</strong> ${escapeHtml (lib.concatStringsSep ", " ctr.ports)}</p>'' else ""}
                </div>
            </div>'';

  packagesSection = if nixPackages == [] then "" else ''
        <section class="download-section">
            <h2>Packages</h2>
            <p>Available Nix packages that can be built from this flake:</p>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>Package</th>
                        <th>Description</th>
                        <th>Build Command</th>
                    </tr>
                </thead>
                <tbody>
${lib.concatStringsSep "\n" (map renderPackage nixPackages)}
                </tbody>
            </table>
        </section>
  '';

  appsSection = if nixApps == [] then "" else ''
        <section class="download-section">
            <h2>Apps</h2>
            <p>Runnable applications for common tasks:</p>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>App</th>
                        <th>Description</th>
                        <th>Run Command</th>
                    </tr>
                </thead>
                <tbody>
${lib.concatStringsSep "\n" (map renderApp nixApps)}
                </tbody>
            </table>
        </section>
  '';

  containersSection = if nixContainers == [] then "" else ''
        <section class="download-section">
            <h2>Container Images</h2>
            <p>Docker/OCI container images built with Nix for reproducible deployments:</p>
            <div class="download-cards">
${lib.concatStringsSep "\n" (map renderContainer nixContainers)}
            </div>
        </section>
  '';

  infrastructureContent =
    htmlHead "QNTX Infrastructure" "." +
    ''
    <body>
        <nav class="doc-nav"><a href="./index.html"><img src="./qntx.jpg" alt="QNTX" class="site-logo">Documentation Home</a></nav>

        <h1>Build Infrastructure</h1>
        <p>QNTX uses <a href="https://nixos.org/">Nix</a> for reproducible builds. All packages, container images, and development tools are defined in <code>flake.nix</code>.</p>

        <section class="download-section">
            <h2>Quick Start</h2>
            <div class="install-code"># Install Nix (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh

# Build QNTX
nix build github:${githubRepo}

# Enter development shell
nix develop github:${githubRepo}</div>
        </section>

${packagesSection}
${appsSection}
${containersSection}

        <section class="download-section">
            <h2>Development Shell</h2>
            <p>The development shell includes all tools needed to build and test QNTX:</p>
            <div class="install-code">nix develop</div>
            <p>This provides: Go, Rust, Python, protobuf, SQLite, and pre-commit hooks.</p>
        </section>

        <section class="download-section">
            <h2>Reproducibility</h2>
            <p>All builds are fully reproducible. The same inputs always produce identical outputs:</p>
            <ul>
                <li><strong>Lockfile:</strong> <code>flake.lock</code> pins all dependencies</li>
                <li><strong>Vendor hash:</strong> Go modules are content-addressed</li>
                <li><strong>Binary cache:</strong> <code>qntx.cachix.org</code> for pre-built artifacts</li>
            </ul>
        </section>

${provenanceFooter}
    </body>
    </html>'';

  infrastructureFile = pkgs.writeTextFile {
    name = "qntx-docs-infrastructure";
    text = infrastructureContent;
    destination = "/infrastructure.html";
  };

in
# Compositional assembly: combine static assets, index, downloads, infrastructure, search index, build info, and all HTML files
pkgs.symlinkJoin {
  name = "qntx-docs-site";
  paths = [ staticAssets indexFile downloadsFile infrastructureFile searchIndexFile buildInfoFile ] ++ htmlDerivations;
}
