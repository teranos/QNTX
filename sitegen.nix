{ pkgs
, gitRevision ? "unknown"
, gitShortRev ? "unknown"
, gitTag ? null
, buildDate ? null
, ciUser ? null
, ciPipeline ? null
, ciRunId ? null
  # Nix infrastructure metadata (passed from flake)
, nixPackages ? []
, nixApps ? []
, nixContainers ? []
}:

let
  inherit (pkgs) lib;

  # GitHub repo for links
  githubRepo = "teranos/QNTX";

  # Provenance info
  provenance = {
    commit = gitShortRev;
    fullCommit = gitRevision;
    tag = gitTag;
    generator = "sitegen.nix";
    date = buildDate;
    user = ciUser;
    pipeline = ciPipeline;
    runId = ciRunId;
  };

  # Static assets
  cssFiles = {
    core = ./web/css/core.css;
    utilities = ./web/css/utilities.css;
    docs = ./web/css/docs.css;
  };
  jsFiles = {
    search = ./web/js/search.js;
    releases = ./web/js/releases.js;
  };
  logo = ./web/qntx.jpg;

  # Use Nix's filesystem library to discover markdown files
  docsDir = ./docs;
  allFiles = lib.filesystem.listFilesRecursive docsDir;
  markdownFiles =
    let filtered = lib.filter (path: lib.hasSuffix ".md" (toString path)) allFiles;
    in if filtered == [ ]
    then throw "No markdown files found in docs/ directory"
    else filtered;

  # Calculate relative path from docs/ directory
  getRelativePath = path:
    lib.removePrefix "${toString docsDir}/" (toString path);

  # SEG symbol mappings for semantic navigation
  # Based on docs/development/design-philosophy.md
  categoryMeta = {
    "getting-started" = { symbol = "‚çü"; desc = "Entry points"; };
    "architecture" = { symbol = "‚å¨"; desc = "System design"; };
    "development" = { symbol = "‚®≥"; desc = "Workflows"; };
    "types" = { symbol = "‚â°"; desc = "Type reference"; };
    "api" = { symbol = "‚ãà"; desc = "API reference"; };
    "testing" = { symbol = "‚ú¶"; desc = "Test guides"; };
    "security" = { symbol = "+"; desc = "Security"; };
    "vision" = { symbol = "‚ü∂"; desc = "Future direction"; };
    "_root" = { symbol = ""; desc = ""; };
  };

  # Get category metadata with fallback
  getCategoryMeta = cat:
    categoryMeta.${cat} or { symbol = ""; desc = ""; };

  # Create structured file info for each markdown file
  mkFileInfo = mdPath:
    let
      relPath = getRelativePath mdPath;
      dir = dirOf relPath;
      name = lib.removeSuffix ".md" (baseNameOf relPath);
      htmlPath = lib.removeSuffix ".md" relPath + ".html";
      depth = lib.length (lib.filter (x: x != "") (lib.splitString "/" (if dir == "." then "" else dir)));
      prefix = if depth == 0 then "." else lib.concatStringsSep "/" (lib.genList (_: "..") depth);
    in
    {
      inherit mdPath relPath dir name htmlPath depth prefix;
    };

  # Process all files to get structured info
  fileInfos = map mkFileInfo markdownFiles;

  # Group files by directory for index generation
  groupedFiles = lib.groupBy (f: if f.dir == "." then "_root" else (lib.head (lib.splitString "/" f.dir))) fileInfos;

  # HTML escaping function to prevent XSS from malicious filenames
  escapeHtml = s: builtins.replaceStrings
    [ "<" ">" "&" "\"" "'" ]
    [ "&lt;" "&gt;" "&amp;" "&quot;" "&#39;" ]
    s;

  # Convert kebab-case to Title Case
  toTitleCase = s:
    let
      words = lib.splitString "-" s;
      capitalize = w: lib.toUpper (lib.substring 0 1 w) + lib.substring 1 (lib.stringLength w) w;
    in
    lib.concatStringsSep " " (map capitalize words);

  # HTML template - head section
  htmlHead = title: prefix: ''
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${escapeHtml title}</title>
        <link rel="icon" type="image/jpeg" href="${prefix}/qntx.jpg">
        <link rel="stylesheet" href="${prefix}/css/core.css">
        <link rel="stylesheet" href="${prefix}/css/docs.css">
    </head>
  '';

  # Provenance footer HTML
  # Build provenance line with available info
  commitLink = ''<a href="https://github.com/${githubRepo}/commit/${provenance.fullCommit}">${provenance.commit}</a>'';
  tagInfo = if provenance.tag != null then " (${provenance.tag})" else "";
  dateInfo = if provenance.date != null then " on ${provenance.date}" else "";
  userInfo = if provenance.user != null then " by ${provenance.user}" else "";
  pipelineInfo =
    if provenance.pipeline != null && provenance.runId != null
    then '' via <a href="https://github.com/${githubRepo}/actions/runs/${provenance.runId}">${provenance.pipeline}</a>''
    else if provenance.pipeline != null
    then " via ${provenance.pipeline}"
    else "";

  provenanceFooter = ''
        <footer class="site-footer">
            <p class="provenance">Generated by ${provenance.generator} at commit ${commitLink}${tagInfo}${dateInfo}${userInfo}${pipelineInfo}</p>
        </footer>
  '';

  # Document page structure
  docBody = prefix: ''
    <body>
        <nav class="doc-nav"><a href="${prefix}/index.html"><img src="${prefix}/qntx.jpg" alt="QNTX" class="site-logo">Documentation Home</a></nav>
  '';

  # Index page structure
  indexBody = ''
    <body>
        <div class="doc-header">
            <img src="./qntx.jpg" alt="QNTX Logo">
            <h1>QNTX Documentation</h1>
        </div>
        <div class="search-container">
            <input type="search" id="search-input" class="search-input" placeholder="Search documentation..." aria-label="Search documentation">
            <div id="search-results" class="search-results" hidden></div>
        </div>

        <nav class="quick-links">
            <a href="./downloads.html" class="quick-link">Downloads</a>
            <a href="./infrastructure.html" class="quick-link">Build Infrastructure</a>
            <a href="./sitegen.html" class="quick-link">Sitegen</a>
        </nav>

        <section class="download-section quick-download">
            <h2>Quick Download</h2>
            <div id="latest-release">
                <p class="loading">Loading latest release...</p>
            </div>
            <p style="margin-top: 12px;"><a href="./downloads.html">View all downloads and installation options</a></p>
        </section>
  '';

  # Category order for consistent display
  categoryOrder = [ "getting-started" "architecture" "development" "types" "api" "security" "testing" "vision" ];

  # Generate index section with SEG symbol
  genIndexSection = category: files:
    let
      sortedFiles = lib.sort (a: b: a.name < b.name) files;
      meta = getCategoryMeta category;
      categoryTitle = toTitleCase category;
      symbolHtml = if meta.symbol != "" then ''<span class="category-symbol">${meta.symbol}</span>'' else "";
      descHtml = if meta.desc != "" then ''<span class="category-desc">${escapeHtml meta.desc}</span>'' else "";
      fileLinks = map (f: ''            <li><a href="${f.htmlPath}"><span class="doc-name">${escapeHtml (toTitleCase f.name)}</span></a></li>'') sortedFiles;
    in
    ''
        <section class="category-section">
            <div class="category-header">
                ${symbolHtml}<h2 class="category-title">${escapeHtml categoryTitle}</h2>${descHtml}
            </div>
            <ul class="doc-list">
    ${lib.concatStringsSep "\n" fileLinks}
            </ul>
        </section>'';

  # Generate full index content
  indexContent =
    let
      rootFiles = groupedFiles._root or [ ];
      # Sort categories by defined order, then alphabetically for any extras
      sortedCategories =
        let
          orderedCats = lib.filter (c: lib.hasAttr c groupedFiles) categoryOrder;
          extraCats = lib.filter (c: c != "_root" && !(lib.elem c categoryOrder)) (lib.attrNames groupedFiles);
        in
        orderedCats ++ (lib.sort (a: b: a < b) extraCats);
      rootSection = if rootFiles != [ ] then genIndexSection "_root" rootFiles else "";
      categorySections = map (cat: genIndexSection cat groupedFiles.${cat}) sortedCategories;
    in
    htmlHead "QNTX Documentation" "." +
    indexBody +
    rootSection +
    lib.concatStringsSep "\n" categorySections +
    provenanceFooter +
    ''
        <script src="./js/search.js"></script>
        <script src="./js/releases.js"></script>
    </body>
    </html>'';

  # Create a separate derivation for each markdown file (enables incremental rebuilds)
  mkHtmlDerivation = fileInfo:
    let
      # Read markdown content and rewrite .md links to .html (pure Nix)
      mdContent = builtins.readFile fileInfo.mdPath;
      rewrittenMd = builtins.replaceStrings [ ".md)" ] [ ".html)" ] mdContent;
    in
    pkgs.runCommand "qntx-doc-${fileInfo.name}"
      {
        nativeBuildInputs = [ pkgs.pulldown-cmark ];
      }
      ''
        mkdir -p "$out/$(dirname "${fileInfo.htmlPath}")"
        {
          cat <<'EOF'
${htmlHead "QNTX - ${fileInfo.name}" fileInfo.prefix}
${docBody fileInfo.prefix}
EOF
          cat <<'EOF' | ${pkgs.pulldown-cmark}/bin/pulldown-cmark -T -S -F
${rewrittenMd}
EOF
          cat <<'EOF'
${provenanceFooter}
EOF
          echo "    </body>"
          echo "</html>"
        } > "$out/${fileInfo.htmlPath}"
      '';

  # Generate all HTML file derivations
  htmlDerivations = map mkHtmlDerivation fileInfos;

  # Generate search index JSON
  # Escape for JSON string values
  escapeJson = s: builtins.replaceStrings
    [ "\\" "\"" "\n" "\r" "\t" ]
    [ "\\\\" "\\\"" "\\n" "\\r" "\\t" ]
    s;

  # Strip markdown syntax for plain text content
  stripMarkdown = s:
    let
      # Remove code blocks
      noCodeBlocks = builtins.replaceStrings [ "```" ] [ "" ] s;
      # Remove headers markers
      noHeaders = builtins.replaceStrings [ "# " "## " "### " "#### " ] [ "" "" "" "" ] noCodeBlocks;
      # Remove emphasis markers
      noEmphasis = builtins.replaceStrings [ "**" "__" "*" "_" "`" ] [ "" "" "" "" "" ] noHeaders;
      # Remove link syntax [text](url) -> text (simplified)
      noLinks = builtins.replaceStrings [ "[" "](" ] [ "" " " ] noEmphasis;
    in
    noLinks;

  # Generate search index entry for a file
  mkSearchEntry = fileInfo:
    let
      mdContent = builtins.readFile fileInfo.mdPath;
      # Get first 500 chars of stripped content for search
      strippedContent = stripMarkdown mdContent;
      truncatedContent = lib.substring 0 500 strippedContent;
      category = if fileInfo.dir == "." then "General" else toTitleCase (lib.head (lib.splitString "/" fileInfo.dir));
    in
    ''{"title":"${escapeJson (toTitleCase fileInfo.name)}","path":"${fileInfo.htmlPath}","category":"${escapeJson category}","content":"${escapeJson truncatedContent}"}'';

  searchIndexContent = "[" + lib.concatStringsSep "," (map mkSearchEntry fileInfos) + "]";

  searchIndexFile = pkgs.writeTextFile {
    name = "qntx-docs-search-index";
    text = searchIndexContent;
    destination = "/search-index.json";
  };

  # Static assets using linkFarm (pure Nix)
  staticAssets = pkgs.linkFarm "qntx-docs-static" [
    { name = "css/core.css"; path = cssFiles.core; }
    { name = "css/utilities.css"; path = cssFiles.utilities; }
    { name = "css/docs.css"; path = cssFiles.docs; }
    { name = "js/search.js"; path = jsFiles.search; }
    { name = "js/releases.js"; path = jsFiles.releases; }
    { name = "qntx.jpg"; path = logo; }
  ];

  # Index file as a derivation
  indexFile = pkgs.writeTextFile {
    name = "qntx-docs-index";
    text = indexContent;
    destination = "/index.html";
  };

  # GitHub release base URL
  githubReleasesUrl = "https://github.com/${githubRepo}/releases";

  # Downloads page content
  downloadsContent =
    htmlHead "QNTX Downloads" "." +
    ''
    <body>
        <nav class="doc-nav"><a href="./index.html"><img src="./qntx.jpg" alt="QNTX" class="site-logo">Documentation Home</a></nav>

        <h1>Download QNTX</h1>

        <section class="download-section">
            <h2>Recommended: Install via Nix</h2>
            <p>The easiest way to install QNTX is using the Nix package manager:</p>
            <div class="install-code">nix profile install github:${githubRepo}</div>
            <p>This installs the latest version and handles all dependencies automatically.</p>
        </section>

        <section class="download-section">
            <h2>Release Downloads</h2>
            <div id="release-downloads">
                <p class="loading">Loading releases...</p>
            </div>
        </section>

        <section class="download-section">
            <h2>Docker Images</h2>
            <div class="download-cards">
                <div class="download-card">
                    <div class="download-card-header">
                        <span class="download-card-icon">üì¶</span>
                        <span class="download-card-title">QNTX Core</span>
                    </div>
                    <p class="download-card-desc">Main QNTX container image with all core functionality.</p>
                    <a href="https://github.com/${githubRepo}/pkgs/container/qntx" class="download-btn">View Image</a>
                </div>

                <div class="download-card">
                    <div class="download-card-header">
                        <span class="download-card-icon">üì¶</span>
                        <span class="download-card-title">qntx-code Plugin</span>
                    </div>
                    <p class="download-card-desc">Code analysis and Git integration plugin.</p>
                    <a href="https://github.com/${githubRepo}/pkgs/container/qntx-code-plugin" class="download-btn">View Image</a>
                </div>

                <div class="download-card">
                    <div class="download-card-header">
                        <span class="download-card-icon">üì¶</span>
                        <span class="download-card-title">qntx-python Plugin</span>
                    </div>
                    <p class="download-card-desc">Python runtime plugin with PyO3 integration.</p>
                    <a href="https://github.com/${githubRepo}/pkgs/container/qntx-python-plugin" class="download-btn">View Image</a>
                </div>
            </div>
        </section>

        <section class="download-section">
            <h2>Build from Source</h2>
            <p>Clone the repository and build with Go 1.24+:</p>
            <div class="install-code">git clone https://github.com/${githubRepo}.git
cd QNTX
make build</div>
            <p>Or use Nix for reproducible builds:</p>
            <div class="install-code">nix build github:${githubRepo}</div>
        </section>

${provenanceFooter}
        <script src="./js/releases.js"></script>
    </body>
    </html>'';

  downloadsFile = pkgs.writeTextFile {
    name = "qntx-docs-downloads";
    text = downloadsContent;
    destination = "/downloads.html";
  };

  # Build info JSON for programmatic access
  # Filter out null values for cleaner JSON
  buildInfoContent = builtins.toJSON (lib.filterAttrs (_: v: v != null) {
    generator = provenance.generator;
    commit = provenance.fullCommit;
    shortCommit = provenance.commit;
    tag = provenance.tag;
    date = provenance.date;
    user = provenance.user;
    pipeline = provenance.pipeline;
    runId = provenance.runId;
    repository = "https://github.com/${githubRepo}";
  });

  buildInfoFile = pkgs.writeTextFile {
    name = "qntx-docs-build-info";
    text = buildInfoContent;
    destination = "/build-info.json";
  };

  # Infrastructure documentation page
  # Generate package list HTML
  renderPackage = pkg: ''
            <tr>
                <td><code>${escapeHtml pkg.name}</code></td>
                <td>${escapeHtml pkg.description}</td>
                <td><code>nix build .#${escapeHtml pkg.name}</code></td>
            </tr>'';

  renderApp = app: ''
            <tr>
                <td><code>${escapeHtml app.name}</code></td>
                <td>${escapeHtml app.description}</td>
                <td><code>nix run .#${escapeHtml app.name}</code></td>
            </tr>'';

  renderContainer = ctr: ''
            <div class="download-card">
                <div class="download-card-header">
                    <span class="download-card-icon">üì¶</span>
                    <span class="download-card-title">${escapeHtml ctr.name}</span>
                </div>
                <p class="download-card-desc">${escapeHtml ctr.description}</p>
                <div class="container-details">
                    <p><strong>Image:</strong> <code>${escapeHtml ctr.image}</code></p>
                    <p><strong>Architectures:</strong> ${escapeHtml (lib.concatStringsSep ", " ctr.architectures)}</p>
                    ${if ctr.ports != [] then ''<p><strong>Ports:</strong> ${escapeHtml (lib.concatStringsSep ", " ctr.ports)}</p>'' else ""}
                </div>
            </div>'';

  packagesSection = if nixPackages == [] then "" else ''
        <section class="download-section">
            <h2>Packages</h2>
            <p>Available Nix packages that can be built from this flake:</p>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>Package</th>
                        <th>Description</th>
                        <th>Build Command</th>
                    </tr>
                </thead>
                <tbody>
${lib.concatStringsSep "\n" (map renderPackage nixPackages)}
                </tbody>
            </table>
        </section>
  '';

  appsSection = if nixApps == [] then "" else ''
        <section class="download-section">
            <h2>Apps</h2>
            <p>Runnable applications for common tasks:</p>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>App</th>
                        <th>Description</th>
                        <th>Run Command</th>
                    </tr>
                </thead>
                <tbody>
${lib.concatStringsSep "\n" (map renderApp nixApps)}
                </tbody>
            </table>
        </section>
  '';

  containersSection = if nixContainers == [] then "" else ''
        <section class="download-section">
            <h2>Container Images</h2>
            <p>Docker/OCI container images built with Nix for reproducible deployments:</p>
            <div class="download-cards">
${lib.concatStringsSep "\n" (map renderContainer nixContainers)}
            </div>
        </section>
  '';

  infrastructureContent =
    htmlHead "QNTX Infrastructure" "." +
    ''
    <body>
        <nav class="doc-nav"><a href="./index.html"><img src="./qntx.jpg" alt="QNTX" class="site-logo">Documentation Home</a></nav>

        <h1>Build Infrastructure</h1>
        <p>QNTX uses <a href="https://nixos.org/">Nix</a> for reproducible builds. All packages, container images, and development tools are defined in <code>flake.nix</code>.</p>

        <section class="download-section">
            <h2>Quick Start</h2>
            <div class="install-code"># Install Nix (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh

# Build QNTX
nix build github:${githubRepo}

# Enter development shell
nix develop github:${githubRepo}</div>
        </section>

${packagesSection}
${appsSection}
${containersSection}

        <section class="download-section">
            <h2>Development Shell</h2>
            <p>The development shell includes all tools needed to build and test QNTX:</p>
            <div class="install-code">nix develop</div>
            <p>This provides: Go, Rust, Python, protobuf, SQLite, and pre-commit hooks.</p>
        </section>

        <section class="download-section">
            <h2>Reproducibility</h2>
            <p>All builds are fully reproducible. The same inputs always produce identical outputs:</p>
            <ul>
                <li><strong>Lockfile:</strong> <code>flake.lock</code> pins all dependencies</li>
                <li><strong>Vendor hash:</strong> Go modules are content-addressed</li>
                <li><strong>Binary cache:</strong> <code>qntx.cachix.org</code> for pre-built artifacts</li>
            </ul>
        </section>

${provenanceFooter}
    </body>
    </html>'';

  infrastructureFile = pkgs.writeTextFile {
    name = "qntx-docs-infrastructure";
    text = infrastructureContent;
    destination = "/infrastructure.html";
  };

  # Generate file structure dynamically from actual outputs
  # Root-level files
  rootFiles = [
    { path = "index.html"; desc = "Main documentation index"; }
    { path = "downloads.html"; desc = "Release downloads (GitHub API)"; }
    { path = "infrastructure.html"; desc = "Nix build documentation"; }
    { path = "sitegen.html"; desc = "This page"; }
    { path = "search-index.json"; desc = "Search index for client-side search"; }
    { path = "build-info.json"; desc = "Provenance metadata"; }
    { path = "qntx.jpg"; desc = "Logo"; }
  ];

  # CSS files from cssFiles attrset
  cssFileList = lib.mapAttrsToList (name: _: { path = "css/${name}.css"; }) cssFiles;

  # JS files from jsFiles attrset
  jsFileList = lib.mapAttrsToList (name: _: { path = "js/${name}.js"; }) jsFiles;

  # Documentation HTML files from fileInfos
  docHtmlFiles = map (f: { path = f.htmlPath; }) fileInfos;

  # Group doc files by directory for tree display
  docFilesByDir = lib.groupBy (f: dirOf f.path) docHtmlFiles;
  docDirs = lib.filter (d: d != ".") (lib.attrNames docFilesByDir);

  # Render a single file entry with tree prefix
  renderFileEntry = prefix: file:
    let descPart = if file ? desc then "  # ${file.desc}" else "";
    in "${prefix}${baseNameOf file.path}${descPart}";

  # Generate the tree structure
  generatedStructure =
    let
      # Root files (sorted)
      sortedRootFiles = lib.sort (a: b: a.path < b.path) rootFiles;
      rootCount = lib.length sortedRootFiles;

      # CSS directory entries
      sortedCssFiles = lib.sort (a: b: a.path < b.path) cssFileList;
      cssCount = lib.length sortedCssFiles;

      # JS directory entries
      sortedJsFiles = lib.sort (a: b: a.path < b.path) jsFileList;
      jsCount = lib.length sortedJsFiles;

      # Doc directories (sorted)
      sortedDocDirs = lib.sort (a: b: a < b) docDirs;

      # Render root files
      rootEntries = lib.imap0 (i: f:
        let prefix = if i == rootCount - 1 && sortedDocDirs == [] then "‚îî‚îÄ‚îÄ " else "‚îú‚îÄ‚îÄ ";
        in renderFileEntry prefix f
      ) sortedRootFiles;

      # Render CSS directory
      cssEntries = ["‚îú‚îÄ‚îÄ css/"] ++ lib.imap0 (i: f:
        let prefix = if i == cssCount - 1 then "‚îÇ   ‚îî‚îÄ‚îÄ " else "‚îÇ   ‚îú‚îÄ‚îÄ ";
        in renderFileEntry prefix f
      ) sortedCssFiles;

      # Render JS directory
      jsEntries = ["‚îú‚îÄ‚îÄ js/"] ++ lib.imap0 (i: f:
        let prefix = if i == jsCount - 1 then "‚îÇ   ‚îî‚îÄ‚îÄ " else "‚îÇ   ‚îú‚îÄ‚îÄ ";
        in renderFileEntry prefix f
      ) sortedJsFiles;

      # Render doc directories
      docDirCount = lib.length sortedDocDirs;
      docDirEntries = lib.concatLists (lib.imap0 (di: dir:
        let
          isLastDir = di == docDirCount - 1;
          dirPrefix = if isLastDir then "‚îî‚îÄ‚îÄ " else "‚îú‚îÄ‚îÄ ";
          filePrefix = if isLastDir then "    " else "‚îÇ   ";
          dirFiles = lib.sort (a: b: a.path < b.path) docFilesByDir.${dir};
          fileCount = lib.length dirFiles;
        in
        ["${dirPrefix}${dir}/"] ++ lib.imap0 (fi: f:
          let fPrefix = if fi == fileCount - 1 then "${filePrefix}‚îî‚îÄ‚îÄ " else "${filePrefix}‚îú‚îÄ‚îÄ ";
          in "${fPrefix}${baseNameOf f.path}"
        ) dirFiles
      ) sortedDocDirs);

    in
    ["qntx-docs-site/"] ++ rootEntries ++ cssEntries ++ jsEntries ++ docDirEntries;

  # Sitegen self-documentation page
  sitegenContent =
    htmlHead "QNTX Sitegen" "." +
    ''
    <body>
        <nav class="doc-nav"><a href="./index.html"><img src="./qntx.jpg" alt="QNTX" class="site-logo">Documentation Home</a></nav>

        <h1>Documentation Generator</h1>
        <p>This documentation site is generated by <code>sitegen.nix</code>, a pure Nix static site generator. No external tools or build steps required beyond Nix itself.</p>

        <section class="download-section">
            <h2>Features</h2>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Pure Nix</strong></td>
                        <td>Entire generator written in Nix - no shell scripts, no external build tools</td>
                    </tr>
                    <tr>
                        <td><strong>Markdown to HTML</strong></td>
                        <td>Converts <code>docs/*.md</code> to HTML using <a href="https://github.com/raphlinus/pulldown-cmark">pulldown-cmark</a></td>
                    </tr>
                    <tr>
                        <td><strong>SEG Symbol Navigation</strong></td>
                        <td>Categories marked with semantic symbols: ‚çü Getting Started, ‚å¨ Architecture, ‚®≥ Development, ‚â° Types, ‚ãà API</td>
                    </tr>
                    <tr>
                        <td><strong>Client-side Search</strong></td>
                        <td>Build-time JSON index with JavaScript search - no server required</td>
                    </tr>
                    <tr>
                        <td><strong>Dark Mode</strong></td>
                        <td>Automatic dark/light theme via <code>prefers-color-scheme</code></td>
                    </tr>
                    <tr>
                        <td><strong>GitHub Releases</strong></td>
                        <td>Dynamic release downloads fetched client-side from GitHub API</td>
                    </tr>
                    <tr>
                        <td><strong>Provenance</strong></td>
                        <td>Every page shows commit, tag, date, CI user, and pipeline info</td>
                    </tr>
                    <tr>
                        <td><strong>Self-documenting Infra</strong></td>
                        <td>Nix packages, apps, and containers documented from flake metadata</td>
                    </tr>
                    <tr>
                        <td><strong>Incremental Builds</strong></td>
                        <td>Each markdown file is a separate derivation for faster rebuilds</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="download-section">
            <h2>Generated Structure</h2>
            <p>This structure is generated dynamically from the actual sitegen outputs (${toString (lib.length fileInfos)} documentation files discovered):</p>
            <div class="install-code">${lib.concatStringsSep "\n" generatedStructure}</div>
        </section>

        <section class="download-section">
            <h2>How It Works</h2>
            <h3>1. Markdown Discovery</h3>
            <p>Uses <code>lib.filesystem.listFilesRecursive</code> to find all <code>.md</code> files in <code>docs/</code>:</p>
            <div class="install-code">markdownFiles = lib.filter (path: lib.hasSuffix ".md" (toString path))
  (lib.filesystem.listFilesRecursive ./docs);</div>

            <h3>2. Per-file Derivations</h3>
            <p>Each markdown file becomes its own Nix derivation, enabling incremental builds:</p>
            <div class="install-code">mkHtmlDerivation = fileInfo:
  pkgs.runCommand "qntx-doc-''${fileInfo.name}" {
    nativeBuildInputs = [ pkgs.pulldown-cmark ];
  } '''
    pulldown-cmark input.md > $out/output.html
  ''';</div>

            <h3>3. Compositional Assembly</h3>
            <p>All derivations combined with <code>symlinkJoin</code>:</p>
            <div class="install-code">pkgs.symlinkJoin {
  name = "qntx-docs-site";
  paths = [ staticAssets indexFile downloadsFile ... ] ++ htmlDerivations;
}</div>
        </section>

        <section class="download-section">
            <h2>Provenance Parameters</h2>
            <p>Sitegen accepts these parameters for build provenance:</p>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>Parameter</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>gitRevision</code></td>
                        <td>string</td>
                        <td>Full commit hash</td>
                    </tr>
                    <tr>
                        <td><code>gitShortRev</code></td>
                        <td>string</td>
                        <td>Short commit hash (displayed)</td>
                    </tr>
                    <tr>
                        <td><code>gitTag</code></td>
                        <td>string?</td>
                        <td>Release tag (e.g., "v1.0.0")</td>
                    </tr>
                    <tr>
                        <td><code>buildDate</code></td>
                        <td>string?</td>
                        <td>Build date (e.g., "2025-01-08")</td>
                    </tr>
                    <tr>
                        <td><code>ciUser</code></td>
                        <td>string?</td>
                        <td>CI actor (e.g., "github-actions")</td>
                    </tr>
                    <tr>
                        <td><code>ciPipeline</code></td>
                        <td>string?</td>
                        <td>Workflow name</td>
                    </tr>
                    <tr>
                        <td><code>ciRunId</code></td>
                        <td>string?</td>
                        <td>GitHub Actions run ID (links to run)</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="download-section">
            <h2>Infrastructure Metadata</h2>
            <p>Pass Nix infrastructure metadata to generate the infrastructure page:</p>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>Parameter</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>nixPackages</code></td>
                        <td>[{name, description}]</td>
                        <td>List of buildable packages</td>
                    </tr>
                    <tr>
                        <td><code>nixApps</code></td>
                        <td>[{name, description}]</td>
                        <td>List of runnable apps</td>
                    </tr>
                    <tr>
                        <td><code>nixContainers</code></td>
                        <td>[{name, description, image, architectures, ports}]</td>
                        <td>List of container images</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="download-section">
            <h2>Building the Site</h2>
            <div class="install-code"># Build docs site
nix build .#docs-site

# Copy to web/site/ for serving
nix run .#build-docs-site

# Serve locally (example with Python)
cd result && python -m http.server 8000</div>
        </section>

        <section class="download-section">
            <h2>Adding Documentation</h2>
            <p>To add new documentation:</p>
            <ol>
                <li>Create a markdown file in <code>docs/</code> (e.g., <code>docs/guides/my-guide.md</code>)</li>
                <li>The file will be automatically discovered and converted to HTML</li>
                <li>Category is determined by the first directory (e.g., <code>guides/</code>)</li>
                <li>Links between docs: use <code>.md</code> extension (auto-rewritten to <code>.html</code>)</li>
            </ol>
        </section>

        <section class="download-section">
            <h2>SEG Category Mapping</h2>
            <p>Directories are mapped to SEG symbols for semantic navigation:</p>
            <table class="nix-table">
                <thead>
                    <tr>
                        <th>Directory</th>
                        <th>Symbol</th>
                        <th>Meaning</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><code>getting-started/</code></td><td>‚çü</td><td>Entry points</td></tr>
                    <tr><td><code>architecture/</code></td><td>‚å¨</td><td>System design</td></tr>
                    <tr><td><code>development/</code></td><td>‚®≥</td><td>Workflows</td></tr>
                    <tr><td><code>types/</code></td><td>‚â°</td><td>Type reference</td></tr>
                    <tr><td><code>api/</code></td><td>‚ãà</td><td>API reference</td></tr>
                    <tr><td><code>testing/</code></td><td>‚ú¶</td><td>Test guides</td></tr>
                    <tr><td><code>security/</code></td><td>+</td><td>Security</td></tr>
                    <tr><td><code>vision/</code></td><td>‚ü∂</td><td>Future direction</td></tr>
                </tbody>
            </table>
        </section>

${provenanceFooter}
    </body>
    </html>'';

  sitegenFile = pkgs.writeTextFile {
    name = "qntx-docs-sitegen";
    text = sitegenContent;
    destination = "/sitegen.html";
  };

in
# Compositional assembly: combine static assets, index, downloads, infrastructure, sitegen, search index, build info, and all HTML files
pkgs.symlinkJoin {
  name = "qntx-docs-site";
  paths = [ staticAssets indexFile downloadsFile infrastructureFile sitegenFile searchIndexFile buildInfoFile ] ++ htmlDerivations;
}
