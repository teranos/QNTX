// Package typegen generates TypeScript type definitions from Go source code.
// It parses Go types annotated with @ts-export and produces equivalent TypeScript interfaces.
package typegen

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
)

// GeneratedHeader is prepended to generated TypeScript files
const GeneratedHeader = `// Code generated by typegen. DO NOT EDIT.
// Source: %s
`

// Generate parses Go source code and generates TypeScript type definitions
// for all structs annotated with // @ts-export.
func Generate(goSource string) (string, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "source.go", goSource, parser.ParseComments)
	if err != nil {
		return "", fmt.Errorf("parse error: %w", err)
	}

	// Build a map of type positions to their preceding comments
	exportedTypes := findExportedTypes(file)
	if len(exportedTypes) == 0 {
		return "", nil
	}

	var result strings.Builder
	first := true

	// Process declarations in order
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			if !exportedTypes[typeSpec.Name.Name] {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			if !first {
				result.WriteString("\n\n")
			}
			first = false

			result.WriteString(generateInterface(typeSpec.Name.Name, structType))
		}
	}

	return result.String(), nil
}

// findExportedTypes finds all type names that have @ts-export annotation
func findExportedTypes(file *ast.File) map[string]bool {
	exported := make(map[string]bool)

	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		// Check for doc comment on the GenDecl itself
		hasExportComment := hasExportAnnotation(genDecl.Doc)

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Check for doc comment on the TypeSpec (for grouped type declarations)
			if hasExportComment || hasExportAnnotation(typeSpec.Doc) || hasExportAnnotation(typeSpec.Comment) {
				exported[typeSpec.Name.Name] = true
			}
		}
	}

	return exported
}

// hasExportAnnotation checks if a comment group contains @ts-export
func hasExportAnnotation(cg *ast.CommentGroup) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, "@ts-export") {
			return true
		}
	}
	return false
}

// generateInterface generates a TypeScript interface from a Go struct
func generateInterface(name string, st *ast.StructType) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("export interface %s {\n", name))

	if st.Fields != nil {
		for _, field := range st.Fields.List {
			if len(field.Names) == 0 {
				// Embedded field - skip for now
				continue
			}

			jsonName, omitempty := parseJSONTag(field.Tag)
			if jsonName == "" || jsonName == "-" {
				continue
			}

			tsType, isPointer := goTypeToTS(field.Type)

			if isPointer && omitempty {
				// Optional field: *T with omitempty -> field?: T
				b.WriteString(fmt.Sprintf("  %s?: %s;\n", jsonName, tsType))
			} else if isPointer {
				// Nullable field: *T without omitempty -> field: T | null
				b.WriteString(fmt.Sprintf("  %s: %s | null;\n", jsonName, tsType))
			} else if omitempty {
				// Optional non-pointer field: T with omitempty -> field?: T
				// Field may be omitted from JSON when it has zero value
				b.WriteString(fmt.Sprintf("  %s?: %s;\n", jsonName, tsType))
			} else {
				b.WriteString(fmt.Sprintf("  %s: %s;\n", jsonName, tsType))
			}
		}
	}

	b.WriteString("}")
	return b.String()
}

// parseJSONTag extracts the json field name and omitempty flag from a struct tag
func parseJSONTag(tag *ast.BasicLit) (name string, omitempty bool) {
	if tag == nil {
		return "", false
	}

	// Remove backticks
	tagValue := strings.Trim(tag.Value, "`")

	// Use reflect.StructTag to parse
	st := reflect.StructTag(tagValue)
	jsonTag := st.Get("json")
	if jsonTag == "" {
		return "", false
	}

	parts := strings.Split(jsonTag, ",")
	name = parts[0]

	for _, part := range parts[1:] {
		if part == "omitempty" {
			omitempty = true
		}
	}

	return name, omitempty
}

// goTypeToTS converts a Go AST type expression to a TypeScript type string.
// Returns the TypeScript type and whether the Go type was a pointer.
func goTypeToTS(expr ast.Expr) (tsType string, isPointer bool) {
	switch t := expr.(type) {
	case *ast.Ident:
		return mapBasicType(t.Name), false

	case *ast.StarExpr:
		// Pointer type - unwrap and mark as pointer
		inner, _ := goTypeToTS(t.X)
		return inner, true

	case *ast.ArrayType:
		if t.Len == nil {
			// Slice: []T -> T[]
			elem, _ := goTypeToTS(t.Elt)
			return elem + "[]", false
		}
		// Fixed array - treat same as slice for JSON
		elem, _ := goTypeToTS(t.Elt)
		return elem + "[]", false

	case *ast.MapType:
		key, _ := goTypeToTS(t.Key)
		val, _ := goTypeToTS(t.Value)
		if key == "string" {
			return fmt.Sprintf("Record<string, %s>", val), false
		}
		// Non-string keys - use generic Record
		return fmt.Sprintf("Record<%s, %s>", key, val), false

	case *ast.SelectorExpr:
		// Qualified type like time.Time
		if ident, ok := t.X.(*ast.Ident); ok {
			return mapQualifiedType(ident.Name, t.Sel.Name), false
		}
		return "unknown", false

	case *ast.InterfaceType:
		// interface{} -> unknown
		return "unknown", false

	default:
		return "unknown", false
	}
}

// mapBasicType maps Go basic types to TypeScript types
func mapBasicType(goType string) string {
	switch goType {
	case "string":
		return "string"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "number"
	case "bool":
		return "boolean"
	case "byte":
		return "number"
	case "rune":
		return "number"
	default:
		// Assume it's a user-defined type, keep the name
		return goType
	}
}

// mapQualifiedType maps qualified types like time.Time
func mapQualifiedType(pkg, name string) string {
	if pkg == "time" && name == "Time" {
		return "string" // JSON serializes time.Time as ISO string
	}
	// For other qualified types, return unknown
	return "unknown"
}

// GenerateFromFile reads a Go source file and generates TypeScript definitions.
func GenerateFromFile(path string) (string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return "", fmt.Errorf("reading file %s: %w", path, err)
	}
	return Generate(string(content))
}

// GenerateFromFiles processes multiple Go source files and combines output.
// Returns TypeScript with a header indicating source files.
func GenerateFromFiles(paths []string) (string, error) {
	var allTypes strings.Builder
	var sources []string

	for _, path := range paths {
		content, err := os.ReadFile(path)
		if err != nil {
			return "", fmt.Errorf("reading file %s: %w", path, err)
		}

		ts, err := Generate(string(content))
		if err != nil {
			return "", fmt.Errorf("processing %s: %w", path, err)
		}

		if ts != "" {
			if allTypes.Len() > 0 {
				allTypes.WriteString("\n\n")
			}
			allTypes.WriteString(ts)
			sources = append(sources, filepath.Base(path))
		}
	}

	if allTypes.Len() == 0 {
		return "", nil
	}

	header := fmt.Sprintf(GeneratedHeader, strings.Join(sources, ", "))
	return header + "\n" + allTypes.String() + "\n", nil
}

// GenerateFromDir finds all .go files in a directory and generates TypeScript.
func GenerateFromDir(dir string) (string, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return "", fmt.Errorf("reading directory %s: %w", dir, err)
	}

	var paths []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if strings.HasSuffix(name, ".go") && !strings.HasSuffix(name, "_test.go") {
			paths = append(paths, filepath.Join(dir, name))
		}
	}

	// Sort for deterministic output
	sort.Strings(paths)

	return GenerateFromFiles(paths)
}
